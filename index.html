<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Drum Machine + Bassline + Trance Lead + Mixer</title>
  <style>
    :root{
      --bg:#ffffff;
      --card:#ffffff;
      --border:#d9d9d9;
      --text:#111;
      --muted:#666;

      --gridBorder:#cfcfcf;
      --cellA:#fff;
      --cellB:#f3f3f3;
      --playhead: rgba(0,0,0,.14);

      --t1:hsl(10 85% 72%);
      --t2:hsl(90 70% 72%);
      --t3:hsl(200 80% 72%);
      --t4:hsl(280 75% 76%);
      --t5:hsl(45 90% 72%);
      --t6:hsl(160 70% 72%);
      --t7:hsl(210 85% 78%);
      --t8:hsl(330 75% 78%);

      --noteGrey:#e6e6e6;
      --noteNat:#ffffff;

      --bassOn:#7f1d1d;   /* diepe rood */
      --leadOn:#6d28d9;   /* paars */

      --headerH:64px;
      --footerH:40px;
      --gap:12px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      overflow:hidden;
    }

    header{
      height:var(--headerH);
      position:sticky; top:0; z-index:50;
      background:#fff;
      border-bottom:1px solid var(--border);
      padding:10px 12px;
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:10px;
    }
    .topLeft,.topRight{display:flex;align-items:center;gap:10px}
    .topLeft{justify-content:flex-start}
    .topMid{display:flex;justify-content:center;gap:10px}
    .topRight{display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap}

    .pill{
      display:flex;align-items:center;gap:10px;
      padding:8px 10px;border:1px solid var(--border);
      border-radius:999px;background:#fff;
      font-size:12px;color:var(--muted);white-space:nowrap;
    }
    .pill strong{color:var(--text);font-weight:950}
    input[type="range"]{accent-color:#111}
    .tempoRange{width:220px}

    button{
      border:1px solid var(--border);
      background:#fff;
      height:40px;
      padding:0 16px;
      border-radius:14px;
      cursor:pointer;
      font-weight:950;
      font-size:15px;
      white-space:nowrap;
      touch-action:manipulation;
    }
    button.primary{background:#111;color:#fff;border-color:#111}
    button:disabled{opacity:.55;cursor:not-allowed}

    .wrap{
      padding:var(--gap);
      height:calc(100vh - var(--headerH) - var(--footerH));
      display:grid;
      grid-template-columns: 1.25fr 1fr 1fr 0.9fr;
      gap:var(--gap);
      align-items:stretch;
      min-height:0;
    }

    .card{
      border:1px solid var(--border);
      border-radius:18px;
      background:#fff;
      box-shadow:0 10px 28px rgba(0,0,0,.06);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .cardHead{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .title{font-size:16px;font-weight:1000;letter-spacing:.2px}
    .smallBtn{
      height:34px;padding:0 12px;border-radius:12px;
      font-size:13px;font-weight:900;
    }

    .body{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1 1 auto;
      min-height:0;
    }

    /* DRUM tools */
    .drumToolsCompact{
      display:flex;flex-wrap:wrap;gap:6px;align-items:center;justify-content:flex-end;
    }
    .drumToolsCompact .smallBtn{height:32px;padding:0 10px;font-size:12px;border-radius:11px}

    .samplerBar{
      display:flex;gap:6px;align-items:center;
      padding:6px 8px;border:1px solid var(--border);
      border-radius:14px;background:#fff;
      flex-wrap:wrap;flex:0 0 auto;
    }
    .samplerStatus{
      font-size:12px;font-weight:950;color:var(--muted);
      white-space:nowrap;max-width:140px;overflow:hidden;text-overflow:ellipsis;
    }
    .samplerKnob{
      display:flex;align-items:center;gap:8px;
      padding:6px 8px;border:1px solid var(--border);
      border-radius:999px;background:#fff;
      font-size:12px;color:var(--muted);
      white-space:nowrap;height:32px;
    }
    .samplerKnob input[type="range"]{width:78px}
    #s1PitchVal,#s2PitchVal{
      display:inline-block;width:3ch;text-align:center;font-variant-numeric:tabular-nums;
    }

    /* DRUM GRID */
    .gridWrap{
      border:1px solid var(--gridBorder);
      border-radius:16px;
      overflow:hidden;
      background:#fff;
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
    }
    .headerRow{
      display:grid;
      grid-template-columns:160px repeat(16,1fr);
      border-bottom:1px solid var(--gridBorder);
      background:#fff;
      flex:0 0 auto;
    }
    .headerCell{
      padding:8px 4px;font-size:10px;color:var(--muted);text-align:center;
      border-left:1px solid var(--gridBorder);font-weight:900;
    }
    .headerCell:first-child{ text-align:left;border-left:none;padding-left:10px; }
    #grid{flex:1 1 auto; min-height:0; overflow:hidden;}
    .row{ display:grid; grid-template-columns:160px repeat(16,1fr); }
    .row+.row{border-top:1px solid var(--gridBorder)}
    .trackCell{
      display:flex; align-items:center; justify-content:space-between;
      gap:8px; padding:8px 10px;
      border-right:1px solid var(--gridBorder);
      background:#fff;
    }
    .trackLeft{display:flex;align-items:center;gap:8px;min-width:0;flex:1 1 auto}
    .swatch{width:12px;height:12px;border-radius:999px;border:1px solid rgba(0,0,0,.12);flex:0 0 auto}
    .trackText{display:flex;flex-direction:column;min-width:0;gap:1px}
    .trackName{
      font-weight:1000;font-size:12px;color:var(--text);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:92px;line-height:1.1;
    }
    .fileLabel{
      font-size:10px;color:var(--muted);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:92px;
    }
    .mini{display:flex;gap:6px;align-items:center;flex:0 0 auto}
    .mini button{height:30px;padding:0 9px;border-radius:11px;font-size:12px;font-weight:950}
    .cell{
      height:38px;border-left:1px solid var(--gridBorder);
      display:flex;align-items:center;justify-content:center;
      background:var(--cellA);cursor:pointer;touch-action:manipulation;
    }
    .cell.alt{background:var(--cellB)}
    .cell.playhead{outline:4px solid var(--playhead);outline-offset:-4px}
    .cell.on.t1{background:var(--t1)}
    .cell.on.t2{background:var(--t2)}
    .cell.on.t3{background:var(--t3)}
    .cell.on.t4{background:var(--t4)}
    .cell.on.t5{background:var(--t5)}
    .cell.on.t6{background:var(--t6)}
    .cell.on.t7{background:var(--t7)}
    .cell.on.t8{background:var(--t8)}

    .statusLine{
      font-size:12px;color:var(--muted);
      display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;
      flex:0 0 auto;
    }

    /* Bass + Lead controls */
    .seqControls{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      margin-bottom:6px; flex:0 0 auto;
    }
    .seqControls .pill input[type="range"]{width:120px}

    .tb_grid{
      display:grid;
      grid-template-columns:58px repeat(8, 1fr);
      column-gap:8px;
      align-items:stretch;
      flex:1 1 auto;
      min-height:0;
    }
    .tb_labels,.tb_col{
      display:grid;
      grid-template-rows:18px 50px 10px repeat(12, minmax(18px, 1fr));
      gap:6px;
      height:100%;
      min-height:0;
    }
    .tb_labels{font-size:12px;color:var(--muted);user-select:none}
    .tb_labels .muted{font-size:11px;font-weight:950;letter-spacing:.2px}
    .tb_stepNum{text-align:center;font-size:12px;font-weight:1000;user-select:none}

    .tb_oct{display:grid;grid-template-rows:repeat(3,1fr);gap:6px;height:50px;margin-bottom:0}
    .tb_octBtn{
      width:100%;height:100%;
      border:1px solid var(--border);
      background:#fff;cursor:pointer;border-radius:8px;touch-action:manipulation;
      font-weight:1000;font-size:12px;line-height:1;
    }
    .tb_spacer{height:10px;}

    .tb_pad{
      width:100%;height:100%;
      border:1px solid var(--border);
      background:var(--noteGrey);
      cursor:pointer;border-radius:10px;touch-action:manipulation;
    }
    .tb_pad.nat{background:var(--noteNat)}

    /* kleuren voor ON pads + octave buttons */
    .bass .tb_pad.on{background:var(--bassOn) !important;border-color:var(--bassOn) !important;}
    .bass .tb_octBtn.on{background:var(--bassOn) !important;border-color:var(--bassOn) !important;color:#fff;}

    .lead .tb_pad.on{background:var(--leadOn) !important;border-color:var(--leadOn) !important;}
    .lead .tb_octBtn.on{background:var(--leadOn) !important;border-color:var(--leadOn) !important;color:#fff;}

    /* MIXER */
    .mixerGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      align-items:stretch;
      flex:1 1 auto;
      min-height:0;
    }
    .chan{
      border:1px solid var(--border);
      border-radius:16px;
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      background:#fff;
    }
    .chanTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex:0 0 auto;
    }
    .chanName{font-weight:1000;font-size:13px;color:var(--text)}
    .muteBtn{
      height:30px;
      padding:0 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:1000;
    }
    .muteBtn.on{background:#111;color:#fff;border-color:#111}

    .faderWrap{
      display:flex;
      gap:10px;
      align-items:flex-end;
      justify-content:space-between;
      flex:1 1 auto;
      min-height:0;
    }
    .faderCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      flex:1 1 0;
      min-height:0;
    }
    .faderLabel{font-size:11px;color:var(--muted);font-weight:950}

    .vfaderShell{
      position:relative;
      width:34px;
      height:220px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .vfader{
      -webkit-appearance:none;
      appearance:none;
      width:220px;
      height:34px;
      background:transparent;
      transform: rotate(-90deg);
      display:block;
      margin:0;
      padding:0;
    }
    .vfader:focus{outline:none}
    .vfader::-webkit-slider-runnable-track{
      height:8px;border-radius:999px;background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.10);
    }
    .vfader::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:26px;height:26px;border-radius:999px;
      background:#111;border:2px solid #111;
      margin-top:-9px;
      cursor:pointer;
    }
    .vfader::-moz-range-track{
      height:8px;border-radius:999px;background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.10);
    }
    .vfader::-moz-range-thumb{
      width:26px;height:26px;border-radius:999px;
      background:#111;border:2px solid #111;
      cursor:pointer;
    }

    footer{
      height:var(--footerH);
      border-top:1px solid var(--border);
      display:grid;
      grid-template-columns: 1.25fr 1fr 1fr 0.9fr;
      gap:var(--gap);
      padding:10px 12px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .footerSpacer{grid-column:1 / span 3;}
    .footerRight{grid-column:4;justify-self:start;font-weight:900;color:var(--muted);}

    @media (max-width:1200px){
      body{overflow:auto}
      .wrap{height:auto;grid-template-columns:1fr;}
      footer{grid-template-columns:1fr;height:auto;}
      .footerSpacer{display:none}
      .footerRight{grid-column:1;justify-self:end}
    }
  </style>
</head>

<body>
  <header>
    <div class="topLeft">
      <div class="pill">
        <span>Tempo</span>
        <input id="tempo" class="tempoRange" type="range" min="80" max="160" value="120">
        <strong id="tempoVal">120</strong>
      </div>
    </div>

    <div class="topMid">
      <button id="masterPlay" class="primary">Play</button>
      <button id="masterStop" disabled>Stop</button>
    </div>

    <div class="topRight">
      <div class="pill">
        <span>Vol</span>
        <input id="masterVol" type="range" min="0" max="1" value="0.9" step="0.01">
      </div>

      <button id="recBtn" class="smallBtn">Record 1:00</button>
      <button id="recStopBtn" class="smallBtn" disabled>Stop Rec</button>
      <button id="recExportBtn" class="smallBtn" disabled>Export WAV</button>
    </div>
  </header>

  <div class="wrap">
    <!-- DRUM MACHINE -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Drum Machine</div>
        <div class="drumToolsCompact">
          <button id="saveFileBtn" class="smallBtn">Save</button>
          <button id="loadFileBtn" class="smallBtn">Load</button>
          <input id="loadFileInput" type="file" accept=".mmjson,application/json" style="display:none" />
          <button id="clear" class="smallBtn">Clear</button>
        </div>
      </div>

      <div class="body">
        <div class="samplerBar">
          <strong style="font-size:12px">Sample 1</strong>
          <button id="s1RecBtn" class="smallBtn">2s</button>
          <button id="s1PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s1ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s1Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s1Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s1Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s1PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s1Status" class="samplerStatus">No sample</span>
        </div>

        <div class="samplerBar">
          <strong style="font-size:12px">Sample 2</strong>
          <button id="s2RecBtn" class="smallBtn">2s</button>
          <button id="s2PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s2ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s2Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s2Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s2Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s2PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s2Status" class="samplerStatus">No sample</span>
        </div>

        <div class="gridWrap">
          <div class="headerRow" id="headerRow"></div>
          <div id="grid"></div>
        </div>

        <div class="statusLine">
          <div id="statusLeft"></div>
          <div id="statusRight"></div>
        </div>
      </div>
    </div>

    <!-- BASSLINE -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Bassline</div>
        <div></div>
      </div>

      <div class="body bass">
        <div class="seqControls">
          <button id="bassReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="cutoff" type="range" min="0" max="1" step="0.001" value="0.28"></div>
          <div class="pill"><span>Res</span><input id="reso" type="range" min="0" max="1" step="0.01" value="0.18"></div>
          <div class="pill"><span>Env</span><input id="env" type="range" min="0" max="1" step="0.01" value="0.32"></div>
          <div class="pill"><span>Decay</span><input id="bDecay" type="range" min="0.08" max="0.60" step="0.01" value="0.28"></div>
          <div class="pill"><span>Mix</span><input id="dMix" type="range" min="0" max="1" step="0.01" value="0.16"></div>
          <div class="pill"><span>FB</span><input id="dFb" type="range" min="0" max="0.75" step="0.01" value="0.20"></div>
        </div>

        <div id="tb_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- TRANCE LEAD -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Trance Lead (2×)</div>
        <div></div>
      </div>

      <div class="body lead">
        <div class="seqControls">
          <button id="leadReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="lCutoff" type="range" min="0" max="1" step="0.001" value="0.36"></div>
          <div class="pill"><span>Res</span><input id="lReso" type="range" min="0" max="1" step="0.01" value="0.20"></div>
          <div class="pill"><span>Env</span><input id="lEnv" type="range" min="0" max="1" step="0.01" value="0.40"></div>
          <div class="pill"><span>Gate</span><input id="lGate" type="range" min="0.10" max="1" step="0.01" value="0.55"></div>
          <div class="pill"><span>Mix</span><input id="lMix" type="range" min="0" max="1" step="0.01" value="0.14"></div>
          <div class="pill"><span>FB</span><input id="lFb" type="range" min="0" max="0.75" step="0.01" value="0.18"></div>
        </div>

        <div id="lead_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- MIXER -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Mixer</div>
        <div></div>
      </div>

      <div class="body">
        <div class="pill" style="justify-content:space-between;gap:12px;">
          <span style="font-weight:950;color:var(--text)">Sidechain</span>
          <input id="sidechainAmt" type="range" min="0" max="1" step="0.01" value="0.22" style="width:180px">
          <strong id="sidechainVal">0.22</strong>
        </div>

        <div class="mixerGrid">
          <!-- Drums -->
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Drums</div>
              <button id="mDrumMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mDrumVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.22">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mDrumLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="1.00">
                </div>
              </div>
            </div>
          </div>

          <!-- Bass -->
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Bass</div>
              <button id="mBassMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mBassVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.22">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mBassLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="1.00">
                </div>
              </div>
            </div>
          </div>

          <!-- Lead -->
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Lead</div>
              <button id="mLeadMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mLeadVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.26">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mLeadLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="1.00">
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="font-size:12px;color:var(--muted);font-weight:900;line-height:1.2">
          Tip: Vol fader: beneden = stil, boven = 0 dB (unity). LPF: beneden = 0 Hz (dicht), boven = open. Sidechain: subtiel pompen op de kick.
        </div>
      </div>
    </div>

  </div>

  <footer>
    <div class="footerSpacer"></div>
    <div class="footerRight">Muziek met meester Luis 2026</div>
  </footer>

  <script>
    (() => {
      "use strict";

      // -----------------
      // Helpers
      // -----------------
      function safeJSONParse(s){ try{ return JSON.parse(s); }catch(_){ return null; } }
      function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

      const tempoEl = document.getElementById("tempo");
      const tempoVal = document.getElementById("tempoVal");
      const masterVol = document.getElementById("masterVol");
      const masterPlayBtn = document.getElementById("masterPlay");
      const masterStopBtn = document.getElementById("masterStop");

      const statusLeft  = document.getElementById("statusLeft");
      const statusRight = document.getElementById("statusRight");
      function setStatus(t){ statusLeft.textContent = t || ""; }

      function tempo(){ return clamp(parseFloat(tempoEl.value||120), 80, 160); }
      function quarterSec(){ return 60/tempo(); }
      function eighthSec(){ return quarterSec()/2; }
      function sixteenthSec(){ return quarterSec()/4; }
      // dotted 1/8 = 3/16
      function dotted8Sec(){ return quarterSec() * 0.75; }

      tempoVal.textContent = String(tempo());

      function bindInput(el, fn){
        el.addEventListener("input", fn, { passive:true });
        el.addEventListener("change", fn, { passive:true });
      }

      function expMap01(x, minHz, maxHz){
        x = clamp(x, 0, 1);
        const a = Math.log(minHz);
        const b = Math.log(maxHz);
        return Math.exp(a + (b-a)*x);
      }

      // -----------------
      // Audio init + buses
      // -----------------
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      let ctx = null;

      let master = null;
      let limiter = null;
      let hp = null;

      let drumBus = null, bassBus = null, leadBus = null;
      let drumGain=null, bassGain=null, leadGain=null;
      let drumLPF=null, bassLPF=null, leadLPF=null;

      // Sidechain gain stages (duck bass/lead)
      let bassDuckGain = null;
      let leadDuckGain = null;

      // recorder
      let recDest = null;
      let mediaRec = null;
      let recChunks = [];
      let recBlob = null;
      let recTimeout = null;
      let recTick = null;
      let recRemaining = 0;

      function ensureAudio(){
        if(ctx) return;
        ctx = new AudioCtx();

        master = ctx.createGain();
        master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);

        // gentle limiter
        limiter = ctx.createDynamicsCompressor();
        limiter.threshold.value = -8;  // gentle
        limiter.knee.value = 8;
        limiter.ratio.value = 6;
        limiter.attack.value = 0.003;
        limiter.release.value = 0.22;

        hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 25;

        drumBus = ctx.createGain();
        bassBus = ctx.createGain();
        leadBus = ctx.createGain();

        drumLPF = ctx.createBiquadFilter(); drumLPF.type="lowpass";
        bassLPF = ctx.createBiquadFilter(); bassLPF.type="lowpass";
        leadLPF = ctx.createBiquadFilter(); leadLPF.type="lowpass";

        drumGain = ctx.createGain();
        bassGain = ctx.createGain();
        leadGain = ctx.createGain();

        // sidechain duck gains before LPF chain
        bassDuckGain = ctx.createGain(); bassDuckGain.gain.value = 1;
        leadDuckGain = ctx.createGain(); leadDuckGain.gain.value = 1;

        drumBus.connect(drumLPF); drumLPF.connect(drumGain); drumGain.connect(master);

        // bass: bus -> duck -> LPF -> gain -> master
        bassBus.connect(bassDuckGain);
        bassDuckGain.connect(bassLPF);
        bassLPF.connect(bassGain);
        bassGain.connect(master);

        // lead: bus -> duck -> LPF -> gain -> master
        leadBus.connect(leadDuckGain);
        leadDuckGain.connect(leadLPF);
        leadLPF.connect(leadGain);
        leadGain.connect(master);

        // recorder tap AFTER limiter (so export sounds like output)
        recDest = ctx.createMediaStreamDestination();
        master.connect(limiter);
        limiter.connect(recDest);

        // output
        limiter.connect(hp);
        hp.connect(ctx.destination);

        applyMixerNow(true);
      }

      async function resumeAudio(){
        ensureAudio();
        try{ await ctx.resume(); }catch(_){}
      }

      bindInput(masterVol, ()=>{
        if(master) master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);
        scheduleSave();
      });

      bindInput(tempoEl, ()=>{
        tempoVal.textContent = String(tempo());
        if(ctx){
          if(s1FX) s1FX.update(false);
          if(s2FX) s2FX.update(false);
          if(bassDelayFX) bassDelayFX.update(false);
          if(leadDelayFX) leadDelayFX.update(false);
        }
        scheduleSave();
      });

      // -----------------
      // Autosave
      // -----------------
      const STORE_KEY = "mm_drum_bass_lead_mixer_v3_mellow";
      let saveTimer = null;
      let dirty = false;

      function markDirty(){ dirty = true; }
      function scheduleSave(){
        markDirty();
        clearTimeout(saveTimer);
        saveTimer = setTimeout(saveNow, 200);
      }
      function saveNow(){
        try{
          localStorage.setItem(STORE_KEY, JSON.stringify(gatherState()));
          dirty = false;
        }catch(_){}
      }
      function loadSaved(){
        const raw = localStorage.getItem(STORE_KEY);
        return raw ? safeJSONParse(raw) : null;
      }
      window.addEventListener("beforeunload", ()=>{ if(dirty) saveNow(); });
      setInterval(()=>{ if(dirty) saveNow(); }, 2000);

      // -----------------
      // Mixer controls (LPF: bottom=0Hz-ish, top=open)
      // -----------------
      const mDrumVolEl = document.getElementById("mDrumVol");
      const mBassVolEl = document.getElementById("mBassVol");
      const mLeadVolEl = document.getElementById("mLeadVol");

      const mDrumLPFEl = document.getElementById("mDrumLPF");
      const mBassLPFEl = document.getElementById("mBassLPF");
      const mLeadLPFEl = document.getElementById("mLeadLPF");

      const mDrumMuteBtn = document.getElementById("mDrumMute");
      const mBassMuteBtn = document.getElementById("mBassMute");
      const mLeadMuteBtn = document.getElementById("mLeadMute");

      const sidechainAmtEl = document.getElementById("sidechainAmt");
      const sidechainValEl = document.getElementById("sidechainVal");
      function sideAmt(){ return clamp(parseFloat(sidechainAmtEl.value||0),0,1); }
      sidechainValEl.textContent = (+sidechainAmtEl.value).toFixed(2);

      const mute = { drums:false, bass:false, lead:false };

      function volFromFader(v){
        v = clamp(+v||0, 0, 1);
        return v;
      }
      function cutoffFromLPFFader(v){
        // bottom ~30Hz (practical "0"), top open
        v = clamp(+v||0, 0, 1);
        return expMap01(v, 30, 20000);
      }

      function applyMixerNow(instant=false){
        if(!ctx) return;
        const t = ctx.currentTime;
        const tau = instant ? 0.001 : 0.02;

        const drumVol = mute.drums ? 0 : volFromFader(mDrumVolEl.value);
        const bassVol = mute.bass ? 0 : volFromFader(mBassVolEl.value);
        const leadVol = mute.lead ? 0 : volFromFader(mLeadVolEl.value);

        const drumCut = cutoffFromLPFFader(mDrumLPFEl.value);
        const bassCut = cutoffFromLPFFader(mBassLPFEl.value);
        const leadCut = cutoffFromLPFFader(mLeadLPFEl.value);

        drumGain.gain.setTargetAtTime(drumVol, t, tau);
        bassGain.gain.setTargetAtTime(bassVol, t, tau);
        leadGain.gain.setTargetAtTime(leadVol, t, tau);

        drumLPF.frequency.setTargetAtTime(drumCut, t, tau);
        bassLPF.frequency.setTargetAtTime(bassCut, t, tau);
        leadLPF.frequency.setTargetAtTime(leadCut, t, tau);

        // mellow: lower Q defaults (still controlled in synth filter)
        drumLPF.Q.setTargetAtTime(0.55, t, tau);
        bassLPF.Q.setTargetAtTime(0.60, t, tau);
        leadLPF.Q.setTargetAtTime(0.55, t, tau);
      }

      function hookMixer(){
        const mixerUpdate = ()=>{
          if(ctx) applyMixerNow(false);
          scheduleSave();
        };

        [mDrumVolEl,mBassVolEl,mLeadVolEl,mDrumLPFEl,mBassLPFEl,mLeadLPFEl].forEach(el=>{
          bindInput(el, mixerUpdate);
        });

        bindInput(sidechainAmtEl, ()=>{
          sidechainValEl.textContent = (+sidechainAmtEl.value).toFixed(2);
          scheduleSave();
        });

        function toggleMute(which, btn){
          mute[which] = !mute[which];
          btn.classList.toggle("on", mute[which]);
          btn.textContent = mute[which] ? "Muted" : "Mute";
          if(ctx) applyMixerNow(false);
          scheduleSave();
        }
        mDrumMuteBtn.addEventListener("click", ()=>toggleMute("drums", mDrumMuteBtn));
        mBassMuteBtn.addEventListener("click", ()=>toggleMute("bass", mBassMuteBtn));
        mLeadMuteBtn.addEventListener("click", ()=>toggleMute("lead", mLeadMuteBtn));
      }

      // -----------------
      // Sidechain (kick ducks bass+lead)
      // -----------------
      function triggerSidechain(time){
        if(!ctx || !bassDuckGain || !leadDuckGain) return;
        const amt = sideAmt();
        if(amt <= 0.0001) return;

        // smooth/mellow pump
        const minGain = 1 - (amt * 0.55);     // depth
        const atk = 0.008;                     // soft attack
        const rel = 0.22;                      // smooth release

        // Bass
        bassDuckGain.gain.cancelScheduledValues(time);
        bassDuckGain.gain.setValueAtTime(bassDuckGain.gain.value, time);
        bassDuckGain.gain.setTargetAtTime(minGain, time, atk);
        bassDuckGain.gain.setTargetAtTime(1.0, time + 0.03, rel);

        // Lead (slightly less duck)
        const minGainL = 1 - (amt * 0.40);
        leadDuckGain.gain.cancelScheduledValues(time);
        leadDuckGain.gain.setValueAtTime(leadDuckGain.gain.value, time);
        leadDuckGain.gain.setTargetAtTime(minGainL, time, atk);
        leadDuckGain.gain.setTargetAtTime(1.0, time + 0.03, rel);
      }

      // -----------------
      // Delay FX helper (dotted 1/8 on bass+lead, quarter on sample 1/2)
      // -----------------
      function makeDelayFX({ mixEl, fbEl }, destBus, timeMode="dotted8"){
        const dry = ctx.createGain();
        const wetIn = ctx.createGain();
        const delay = ctx.createDelay(2.0);
        const fb = ctx.createGain();
        const wetOut = ctx.createGain();

        wetIn.connect(delay);
        delay.connect(wetOut);
        wetOut.connect(destBus);

        delay.connect(fb);
        fb.connect(delay);

        dry.connect(destBus);

        function update(instant=false){
          const t = ctx.currentTime;
          const dt = (timeMode==="dotted8") ? dotted8Sec() : quarterSec();
          const mix = clamp(parseFloat(mixEl.value||0), 0, 1);
          const fbb = clamp(parseFloat(fbEl.value||0), 0, 0.75);

          const tau = instant ? 0.001 : 0.02;
          delay.delayTime.setTargetAtTime(dt, t, tau);
          fb.gain.setTargetAtTime(fbb, t, tau);

          dry.gain.setTargetAtTime(1 - mix, t, tau);
          wetIn.gain.setTargetAtTime(mix, t, tau);
        }

        update(true);
        return { dry, wetIn, update };
      }

      // -----------------
      // DRUM MACHINE
      // -----------------
      const headerRow = document.getElementById("headerRow");
      const gridEl    = document.getElementById("grid");
      const clearBtn  = document.getElementById("clear");

      const s1RecBtn   = document.getElementById("s1RecBtn");
      const s1PlayBtn  = document.getElementById("s1PlayBtn");
      const s1ClearBtn = document.getElementById("s1ClearBtn");
      const s1Status   = document.getElementById("s1Status");
      const s1MixEl    = document.getElementById("s1Mix");
      const s1FbEl     = document.getElementById("s1Fb");
      const s1PitchEl  = document.getElementById("s1Pitch");
      const s1PitchVal = document.getElementById("s1PitchVal");

      const s2RecBtn   = document.getElementById("s2RecBtn");
      const s2PlayBtn  = document.getElementById("s2PlayBtn");
      const s2ClearBtn = document.getElementById("s2ClearBtn");
      const s2Status   = document.getElementById("s2Status");
      const s2MixEl    = document.getElementById("s2Mix");
      const s2FbEl     = document.getElementById("s2Fb");
      const s2PitchEl  = document.getElementById("s2Pitch");
      const s2PitchVal = document.getElementById("s2PitchVal");

      function sampleRateFromSemis(semis){ return Math.pow(2, (semis/12)); }
      function fmtPitch(v){
        v = Math.max(-12, Math.min(12, (v|0)));
        const sign = (v >= 0) ? "+" : "-";
        const n = String(Math.abs(v)).padStart(2,"0");
        return sign + n;
      }

      const STEPS = 16;
      const activeSources = new Set();

      const TRACKS_DEF = [
        { name:"Kick",     key:"kick",     colorClass:"t1" },
        { name:"Snare",    key:"snare",    colorClass:"t2" },
        { name:"Hat",      key:"hat",      colorClass:"t3" },
        { name:"OpenHat",  key:"openhat",  colorClass:"t7" },
        { name:"Clap",     key:"clap",     colorClass:"t4" },
        { name:"Perc",     key:"perc",     colorClass:"t5" },
        { name:"Sample 1", key:"sample1",  colorClass:"t6", isSampler:true, samplerId:1 },
        { name:"Sample 2", key:"sample2",  colorClass:"t8", isSampler:true, samplerId:2 },
      ];

      let tracks = TRACKS_DEF.map(t => ({
        ...t,
        fileLabel: t.isSampler ? "No sample" : "Loading…",
        buffer: null,
        pattern: Array(STEPS).fill(false),
      }));

      const sample1Track = tracks.find(t => t.key === "sample1");
      const sample2Track = tracks.find(t => t.key === "sample2");

      let s1FX = null, s2FX = null;

      function playBufferAt(buf, time, destination){
        if(!ctx || !destination || !buf) return;
        const src = ctx.createBufferSource();
        src.buffer = buf;
        src.connect(destination);

        activeSources.add(src);
        src.onended = () => activeSources.delete(src);

        try{ src.start(time); }catch(_){}
        return src;
      }

      function hardStopAllSources(){
        for(const src of Array.from(activeSources)){
          try{ src.stop(0); }catch(_){}
          activeSources.delete(src);
        }
      }

      function applyTinyFade(buf, fadeMs = 2){
        if(!buf || !ctx) return buf;
        const sr = buf.sampleRate;
        const n = Math.max(1, Math.floor(sr * (fadeMs/1000)));
        for(let c=0;c<buf.numberOfChannels;c++){
          const d = buf.getChannelData(c);
          const L = d.length;
          const nn = Math.min(n, Math.floor(L/2));
          for(let i=0;i<nn;i++){
            const g = (nn<=1) ? 1 : (i/(nn-1));
            d[i] *= g;
            d[L-1-i] *= g;
          }
        }
        return buf;
      }

      function trimBufferPrecise(buf, {
        thr = 0.018,
        minRunMs = 2.0,
        prerollMs = 6.0,
        tailThr = 0.012,
        tailHoldMs = 25.0
      } = {}){
        const sr = buf.sampleRate;
        const len = buf.length;
        const ch0 = buf.getChannelData(0);

        const minRun = Math.max(1, Math.floor(sr * (minRunMs/1000)));
        const preroll = Math.floor(sr * (prerollMs/1000));
        const tailHold = Math.max(1, Math.floor(sr * (tailHoldMs/1000)));

        let start = 0, run = 0, found = false;
        for(let i=0;i<len;i++){
          const a = Math.abs(ch0[i]);
          if(a >= thr){
            run++;
            if(run >= minRun){
              start = Math.max(0, i - run + 1 - preroll);
              found = true;
              break;
            }
          }else run = 0;
        }
        if(!found) return buf;

        let end = len;
        let quietRun = 0;
        for(let i=len-1;i>=0;i--){
          const a = Math.abs(ch0[i]);
          if(a < tailThr){
            quietRun++;
            if(quietRun >= tailHold){
              end = Math.min(len, i + quietRun);
              break;
            }
          }else quietRun = 0;
        }

        const minKeep = Math.floor(sr * 0.06);
        if(end - start < minKeep) end = Math.min(len, start + minKeep);

        start = Math.max(0, Math.min(start, len-1));
        end = Math.max(start+1, Math.min(end, len));

        const outLen = end - start;
        const out = ctx.createBuffer(buf.numberOfChannels, outLen, sr);
        for(let c=0;c<buf.numberOfChannels;c++){
          const src = buf.getChannelData(c);
          const dst = out.getChannelData(c);
          dst.set(src.subarray(start, end));
        }
        return out;
      }

      function ensureSampleFX(){
        if(s1FX && s2FX) return;
        // samples keep quarter delay
        s1FX = makeDelayFX({ mixEl:s1MixEl, fbEl:s1FbEl }, drumBus, "quarter");
        s2FX = makeDelayFX({ mixEl:s2MixEl, fbEl:s2FbEl }, drumBus, "quarter");
      }

      function setSamplerUI(which, has){
        const is1 = which === 1;
        const playBtn = is1 ? s1PlayBtn : s2PlayBtn;
        const clrBtn  = is1 ? s1ClearBtn : s2ClearBtn;
        const status  = is1 ? s1Status : s2Status;
        const tr      = is1 ? sample1Track : sample2Track;

        playBtn.disabled = !has;
        clrBtn.disabled  = !has;

        if(!has){
          status.textContent = "No sample";
          tr.fileLabel = "No sample";
        }else{
          status.textContent = "Sample ready ✅";
          tr.fileLabel = "Recorded";
        }
      }
      setSamplerUI(1,false);
      setSamplerUI(2,false);

      let _rec=null, _chunks=[], _stream=null, _recWhich=1;

      async function recordSample2s(which){
        await resumeAudio();
        ensureSampleFX();

        if(!navigator.mediaDevices?.getUserMedia){
          alert("Microfoon werkt niet in deze browser.");
          return;
        }
        if(_rec && _rec.state === "recording") return;

        _recWhich = which;
        (which===1 ? s1Status : s2Status).textContent = "Recording…";
        (which===1 ? s1PlayBtn : s2PlayBtn).disabled = true;
        (which===1 ? s1ClearBtn : s2ClearBtn).disabled = true;

        try{
          _stream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
          });

          _chunks = [];
          _rec = new MediaRecorder(_stream);

          _rec.ondataavailable = (e)=>{ if(e.data && e.data.size) _chunks.push(e.data); };

          _rec.onstop = async ()=>{
            const tr = (_recWhich===1) ? sample1Track : sample2Track;
            try{
              const blob = new Blob(_chunks, { type: _rec.mimeType || "audio/webm" });
              const arr = await blob.arrayBuffer();
              const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
              const trimmed = trimBufferPrecise(buf, {});
              tr.buffer = applyTinyFade(trimmed, 2);
              setSamplerUI(_recWhich, true);
              renderDrum();
              scheduleSave();
            }catch(err){
              console.error(err);
              tr.buffer = null;
              setSamplerUI(_recWhich, false);
              (tr===sample1Track ? s1Status : s2Status).textContent = "Sample failed";
              renderDrum();
            }finally{
              if(_stream) _stream.getTracks().forEach(t=>t.stop());
              _stream = null;
            }
          };

          _rec.start();
          setTimeout(()=>{ if(_rec && _rec.state === "recording"){ try{ _rec.stop(); }catch(_){}} }, 2000);

        }catch(err){
          console.error(err);
          (which===1 ? s1Status : s2Status).textContent = "Mic blocked";
          setSamplerUI(which, false);
        }
      }

      function playSampleNow(which, time){
        const tr = (which===1) ? sample1Track : sample2Track;
        if(!tr.buffer || !ctx) return;

        ensureSampleFX();
        const fx = (which===1) ? s1FX : s2FX;
        fx.update(false);

        const t = (typeof time === "number") ? time : ctx.currentTime;
        const src = ctx.createBufferSource();
        src.buffer = tr.buffer;

        const semis = (which===1 ? (+s1PitchEl.value||0) : (+s2PitchEl.value||0));
        src.playbackRate.setValueAtTime(sampleRateFromSemis(semis), t);

        src.connect(fx.dry);
        src.connect(fx.wetIn);

        activeSources.add(src);
        src.onended = () => activeSources.delete(src);

        try{ src.start(t); }catch(_){}
      }

      function clearSample(which){
        const tr = (which===1) ? sample1Track : sample2Track;
        tr.buffer = null;
        setSamplerUI(which, false);
        renderDrum();
        scheduleSave();
      }

      bindInput(s1PitchEl, ()=>{ s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0); scheduleSave(); });
      bindInput(s2PitchEl, ()=>{ s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0); scheduleSave(); });
      s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0);
      s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0);

      function hookSamplerKnobs(which){
        const mixEl = which===1 ? s1MixEl : s2MixEl;
        const fbEl  = which===1 ? s1FbEl  : s2FbEl;
        bindInput(mixEl, ()=>{ if(ctx){ ensureSampleFX(); (which===1?s1FX:s2FX).update(false); } scheduleSave(); });
        bindInput(fbEl,  ()=>{ if(ctx){ ensureSampleFX(); (which===1?s1FX:s2FX).update(false); } scheduleSave(); });
      }
      hookSamplerKnobs(1);
      hookSamplerKnobs(2);

      s1RecBtn.addEventListener("click", ()=>recordSample2s(1));
      s2RecBtn.addEventListener("click", ()=>recordSample2s(2));
      s1PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(1, ctx.currentTime); });
      s2PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(2, ctx.currentTime); });
      s1ClearBtn.addEventListener("click", ()=>clearSample(1));
      s2ClearBtn.addEventListener("click", ()=>clearSample(2));

      async function fetchArrayBuffer(url){
        const r = await fetch(url, { cache:"no-store" });
        if(!r.ok) throw new Error("HTTP " + r.status);
        return await r.arrayBuffer();
      }

      async function loadOneTrack(tr){
        tr.buffer = null;
        tr.fileLabel = "Missing file";
        for(const ext of ["wav","mp3","ogg"]){
          const url = "./samples/" + tr.key + "." + ext;
          try{
            const arr = await fetchArrayBuffer(url);
            const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
            tr.buffer = buf;
            tr.fileLabel = tr.key + "." + ext;
            return true;
          }catch(_){}
        }
        return false;
      }

      async function loadAllSounds(){
        await resumeAudio();
        setStatus("Loading sounds…");
        renderDrum();

        let ok = 0;
        for(const tr of tracks){
          if(tr.isSampler){
            tr.fileLabel = tr.buffer ? "Recorded" : "No sample";
            continue;
          }
          if(await loadOneTrack(tr)) ok++;
          renderDrum();
        }
        setStatus(ok ? `Ready (${ok}/${tracks.filter(t=>!t.isSampler).length}).` : "No sounds loaded (check ./samples filenames).");
        renderDrum();
      }

      let drumIsRunning=false, drumStep=0, drumNextTime=0, drumTimer=null;
      let playStep=0, rafId=null;

      function scheduleDrumStep(stepIndex,time){
        for(const tr of tracks){
          if(tr.pattern[stepIndex]){
            // SIDECHAIN on kick triggers
            if(tr.key === "kick") triggerSidechain(time);

            if(tr.isSampler){
              if(tr.key === "sample1") playSampleNow(1, time);
              else if(tr.key === "sample2") playSampleNow(2, time);
            }else if(tr.buffer){
              playBufferAt(tr.buffer, time, drumBus);
            }
          }
        }
      }

      const AHEAD_SEC = 0.04;
      const LOOKAHEAD_MS = 15;

      function drumScheduler(){
        if(!drumIsRunning) return;
        const base = sixteenthSec();
        while(drumNextTime < ctx.currentTime + AHEAD_SEC){
          scheduleDrumStep(drumStep, drumNextTime);
          drumStep = (drumStep + 1) % 16;
          drumNextTime += base;
        }
        drumTimer = setTimeout(drumScheduler, LOOKAHEAD_MS);
      }

      let sharedStartTime=0;

      function updatePlayhead(){
        if(!drumIsRunning) return;
        const base = sixteenthSec();
        const elapsed = ctx.currentTime - sharedStartTime;
        const idx = ((elapsed/base)%16 + 16)%16;
        const newStep = Math.floor(idx);
        if(newStep !== playStep){
          playStep = newStep;
          renderDrum();
        }
        rafId = requestAnimationFrame(updatePlayhead);
      }

      function drumStart(t0){
        const ok = tracks.some(tr => !!tr.buffer);
        if(!ok){
          setStatus("No sounds (load ./samples or record Sample).");
          return false;
        }
        drumIsRunning=true;
        drumStep=0;
        playStep=0;
        drumNextTime=t0;

        if(drumTimer) clearTimeout(drumTimer);
        if(rafId) cancelAnimationFrame(rafId);

        renderDrum();
        rafId = requestAnimationFrame(updatePlayhead);
        drumScheduler();
        return true;
      }

      function drumStop(){
        drumIsRunning=false;
        if(drumTimer) clearTimeout(drumTimer);
        drumTimer=null;
        if(rafId) cancelAnimationFrame(rafId);
        rafId=null;
        hardStopAllSources();
        playStep=0;
        renderDrum();
      }

      function buildHeader(){
        headerRow.innerHTML = "";
        const left = document.createElement("div");
        left.className = "headerCell";
        left.textContent = "Sounds";
        headerRow.appendChild(left);

        for(let s=0;s<16;s++){
          const d=document.createElement("div");
          d.className="headerCell";
          d.textContent = (s%4===0) ? String((s/4)+1) : "";
          headerRow.appendChild(d);
        }
      }

      function renderDrum(){
        gridEl.innerHTML = "";
        tracks.forEach(tr=>{
          const row=document.createElement("div");
          row.className="row";

          const trackCell=document.createElement("div");
          trackCell.className="trackCell";

          const left=document.createElement("div");
          left.className="trackLeft";

          const sw=document.createElement("div");
          sw.className="swatch";
          sw.style.background = (getComputedStyle(document.documentElement).getPropertyValue(`--${tr.colorClass}`).trim() || "#ccc");
          left.appendChild(sw);

          const text=document.createElement("div");
          text.className="trackText";

          const name=document.createElement("div");
          name.className="trackName";
          name.textContent = tr.name + (tr.isSampler ? (tr.buffer ? "" : " ") : (tr.buffer ? "" : " ⚠"));

          const file=document.createElement("div");
          file.className="fileLabel";
          file.textContent = tr.fileLabel;

          text.appendChild(name);
          text.appendChild(file);
          left.appendChild(text);

          trackCell.appendChild(left);

          const mini=document.createElement("div");
          mini.className="mini";
          const prev=document.createElement("button");
          prev.textContent="▶";
          prev.className="smallBtn";
          prev.disabled = !tr.buffer;
          prev.addEventListener("click", async ()=>{
            await resumeAudio();
            if(tr.isSampler){
              if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
              if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
            }else{
              playBufferAt(tr.buffer, ctx.currentTime, drumBus);
            }
          });
          mini.appendChild(prev);
          trackCell.appendChild(mini);

          row.appendChild(trackCell);

          for(let s=0;s<16;s++){
            const cell=document.createElement("div");
            cell.className = "cell" + ((((s+1)%2)?" alt":""));
            if(tr.pattern[s]) cell.classList.add("on", tr.colorClass);
            if(drumIsRunning && s===playStep) cell.classList.add("playhead");

            cell.addEventListener("click", async ()=>{
              tr.pattern[s] = !tr.pattern[s];
              await resumeAudio();

              if(tr.pattern[s]){
                if(tr.isSampler){
                  if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
                  if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
                }else if(tr.buffer){
                  playBufferAt(tr.buffer, ctx.currentTime, drumBus);
                }
              }
              renderDrum();
              scheduleSave();
            });

            row.appendChild(cell);
          }

          gridEl.appendChild(row);
        });
      }

      clearBtn.addEventListener("click", ()=>{
        for(const tr of tracks) tr.pattern.fill(false);
        renderDrum();
        setStatus("");
        scheduleSave();
      });

      // -----------------
      // Bass + Lead Sequencer Grids
      // - Octave per step: 3 buttons (no icons)
      // - Middle is default (0), top = +12, bottom = -12
      // - C is bottom row in UI
      // - NO playhead visuals here
      // -----------------
      const bassResetBtn = document.getElementById("bassReset");
      const leadResetBtn = document.getElementById("leadReset");

      const cutEl = document.getElementById("cutoff");
      const resEl = document.getElementById("reso");
      const envEl = document.getElementById("env");
      const bDecayEl = document.getElementById("bDecay");
      const dMixEl = document.getElementById("dMix");
      const dFbEl  = document.getElementById("dFb");

      const lCutEl = document.getElementById("lCutoff");
      const lResEl = document.getElementById("lReso");
      const lEnvEl = document.getElementById("lEnv");
      const lGateEl= document.getElementById("lGate");
      const lMixEl = document.getElementById("lMix");
      const lFbEl  = document.getElementById("lFb");

      const tbGridEl   = document.getElementById("tb_grid");
      const leadGridEl = document.getElementById("lead_grid");

      // UI note order: top high -> bottom C
      const NOTE_NAMES = ["B","A#","A","G#","G","F#","F","E","D#","D","C#","C"];
      const NOTE_TO_SEMI = {
        "C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11
      };

      function makeSeqState(){
        return { steps: Array.from({length:8}, ()=>({ note:null, oct:0 })) };
      }

      let bassState = makeSeqState();
      let leadState = makeSeqState();

      function renderSeqGrid(rootEl, state, kind){
        rootEl.innerHTML = "";

        const labels = document.createElement("div");
        labels.className = "tb_labels";

        const l0 = document.createElement("div");
        l0.className = "muted";
        l0.textContent = "";
        labels.appendChild(l0);

        const l1 = document.createElement("div");
        l1.className = "muted";
        l1.textContent = "Oct";
        labels.appendChild(l1);

        const l2 = document.createElement("div");
        l2.className = "tb_spacer";
        labels.appendChild(l2);

        for(const n of NOTE_NAMES){
          const ln = document.createElement("div");
          ln.className = "muted";
          ln.style.display="flex";
          ln.style.alignItems="center";
          ln.style.justifyContent="flex-start";
          ln.textContent = n;
          labels.appendChild(ln);
        }

        rootEl.appendChild(labels);

        for(let s=0;s<8;s++){
          const col = document.createElement("div");
          col.className = "tb_col";

          const stepNum = document.createElement("div");
          stepNum.className = "tb_stepNum";
          stepNum.textContent = String(s+1);
          col.appendChild(stepNum);

          const octWrap = document.createElement("div");
          octWrap.className = "tb_oct";

          const btnTop = document.createElement("button");
          btnTop.className = "tb_octBtn";
          btnTop.textContent = "";
          btnTop.addEventListener("click", ()=>{
            state.steps[s].oct = +1;
            renderSeqGrid(rootEl, state, kind);
            scheduleSave();
          });

          const btnMid = document.createElement("button");
          btnMid.className = "tb_octBtn";
          btnMid.textContent = "";
          btnMid.addEventListener("click", ()=>{
            state.steps[s].oct = 0;
            renderSeqGrid(rootEl, state, kind);
            scheduleSave();
          });

          const btnBot = document.createElement("button");
          btnBot.className = "tb_octBtn";
          btnBot.textContent = "";
          btnBot.addEventListener("click", ()=>{
            state.steps[s].oct = -1;
            renderSeqGrid(rootEl, state, kind);
            scheduleSave();
          });

          btnTop.classList.toggle("on", state.steps[s].oct === +1);
          btnMid.classList.toggle("on", state.steps[s].oct === 0);
          btnBot.classList.toggle("on", state.steps[s].oct === -1);

          octWrap.appendChild(btnTop);
          octWrap.appendChild(btnMid);
          octWrap.appendChild(btnBot);

          col.appendChild(octWrap);

          const spacer = document.createElement("div");
          spacer.className = "tb_spacer";
          col.appendChild(spacer);

          for(const n of NOTE_NAMES){
            const pad = document.createElement("button");
            pad.className = "tb_pad nat";
            const isOn = state.steps[s].note === n;
            if(isOn) pad.classList.add("on");

            pad.addEventListener("click", async ()=>{
              await resumeAudio();
              if(state.steps[s].note === n) state.steps[s].note = null;
              else state.steps[s].note = n;

              if(state.steps[s].note){
                if(kind==="bass") playBassNoteNow(s);
                else playLeadNoteNow(s);
              }
              renderSeqGrid(rootEl, state, kind);
              scheduleSave();
            });

            col.appendChild(pad);
          }

          rootEl.appendChild(col);
        }

        rootEl.classList.toggle("bass", kind==="bass");
        rootEl.classList.toggle("lead", kind==="lead");
      }

      // -----------------
      // Synths (smooth & mellow)
      // -----------------
      let bassDelayFX = null;
      let leadDelayFX = null;

      function ensureBassLeadFX(){
        if(bassDelayFX && leadDelayFX) return;
        bassDelayFX = makeDelayFX({ mixEl:dMixEl, fbEl:dFbEl }, bassBus, "dotted8");
        leadDelayFX = makeDelayFX({ mixEl:lMixEl, fbEl:lFbEl }, leadBus, "dotted8");
      }

      function makeMonoSynth({ type="sawtooth", bus, baseCutMin=60, baseCutMax=12000, mellow=false }){
        const input = ctx.createGain();

        const filt = ctx.createBiquadFilter();
        filt.type = "lowpass";
        filt.frequency.value = 900;
        filt.Q.value = 0.8;

        // extra post-filter de-click
        const out = ctx.createGain();
        out.gain.value = 1.0;

        input.connect(filt);
        filt.connect(out);
        out.connect(bus);

        function setFilter01(x, t, tau){
          // mellow: cap the top a bit
          const maxHz = mellow ? Math.min(baseCutMax, 12000) : baseCutMax;
          const hz = expMap01(x, baseCutMin, maxHz);
          filt.frequency.setTargetAtTime(hz, t, tau);
        }

        function setRes01(x, t, tau){
          // mellow & responsive but not whistly
          const xx = Math.pow(clamp(x,0,1), 1.35);
          const qMax = mellow ? 10.0 : 18.5;
          const q = 0.5 + xx * qMax;
          filt.Q.setTargetAtTime(q, t, tau);
        }

        function trigger({
          freq,
          time,
          decay=0.22,
          gate=0.55,
          envAmt=0.35,
          baseCut01=0.30,
          release=0.14,
          vel=1.0
        }){
          const osc = ctx.createOscillator();
          osc.type = type;

          const vca = ctx.createGain();
          const vPost = ctx.createGain(); // post-filter de-click ramp

          // --- amp env (smooth) ---
          const atk = 0.003; // a little softer than before
          const dcy = clamp(decay, 0.05, 1.20);
          const sus = clamp(gate, 0.05, 1.0);

          vca.gain.setValueAtTime(0.0001, time);
          vca.gain.setTargetAtTime(vel, time, atk);
          vca.gain.setTargetAtTime(vel * sus, time + 0.02, dcy);

          // release to silence
          vca.gain.setTargetAtTime(0.0001, time + dcy + 0.02, release);

          // --- post de-click (insurance) ---
          vPost.gain.setValueAtTime(0.0001, time);
          vPost.gain.setTargetAtTime(1.0, time, 0.004);
          vPost.gain.setTargetAtTime(0.0001, time + dcy + release + 0.06, 0.010);

          osc.frequency.setValueAtTime(freq, time);
          osc.connect(vca);
          vca.connect(input);
          // post chain
          // (post gain is in parallel via input->filter->out, so we attach it as a multiplier on input level)
          // easiest: multiply input by vPost
          // (we do this by inserting vPost before input)
          // to keep structure simple, we just apply vPost to input gain:
          // Create a temp inputGain:
          const inputGain = ctx.createGain();
          inputGain.gain.setValueAtTime(1.0, time);
          vca.disconnect();
          vca.connect(inputGain);
          inputGain.connect(input);

          inputGain.gain.setValueAtTime(0.0001, time);
          inputGain.gain.setTargetAtTime(1.0, time, 0.004);
          inputGain.gain.setTargetAtTime(0.0001, time + dcy + release + 0.06, 0.010);

          // --- filter env (NO "opens again" at 0) ---
          const t = time;
          const tau = 0.015;

          const base = clamp(baseCut01, 0, 1);
          const env = clamp(envAmt, 0, 1);

          // crucial: when env=0, peak==base (no movement)
          const peak = clamp(base + env * 0.70, 0, 1);

          setFilter01(base, t, 0.001);
          setFilter01(peak, t + 0.02, tau);
          // return to base only if env>0 (otherwise it can feel like "movement")
          if(env > 0.0005){
            setFilter01(base, t + dcy + 0.10, 0.06);
          }

          try{ osc.start(time); osc.stop(time + dcy + release + 0.35); }catch(_){}
        }

        return { trigger, setFilter01, setRes01 };
      }

      let bassSynth = null, leadSynth = null;
      let bassSend = null, leadSend = null;

      function ensureSynths(){
        if(bassSynth && leadSynth) return;
        ensureBassLeadFX();

        // mellow defaults
        bassSynth = makeMonoSynth({ type:"sawtooth", bus:bassBus, baseCutMin:45, baseCutMax:6500, mellow:true });
        leadSynth = makeMonoSynth({ type:"sawtooth", bus:leadBus, baseCutMin:120, baseCutMax:12000, mellow:true });

        bassSend = ctx.createGain();
        leadSend = ctx.createGain();

        bassBus.connect(bassSend);
        leadBus.connect(leadSend);

        bassSend.connect(bassDelayFX.dry);
        bassSend.connect(bassDelayFX.wetIn);

        leadSend.connect(leadDelayFX.dry);
        leadSend.connect(leadDelayFX.wetIn);

        bassDelayFX.update(true);
        leadDelayFX.update(true);
      }

      function applyBassParams(instant=false){
        if(!ctx || !bassSynth) return;
        const t = ctx.currentTime;
        const tau = instant ? 0.001 : 0.03;
        bassSynth.setFilter01(+cutEl.value, t, tau);
        bassSynth.setRes01(+resEl.value, t, tau);
        if(bassDelayFX) bassDelayFX.update(instant);
      }
      function applyLeadParams(instant=false){
        if(!ctx || !leadSynth) return;
        const t = ctx.currentTime;
        const tau = instant ? 0.001 : 0.03;
        leadSynth.setFilter01(+lCutEl.value, t, tau);
        leadSynth.setRes01(+lResEl.value, t, tau);
        if(leadDelayFX) leadDelayFX.update(instant);
      }

      bindInput(cutEl, ()=>{ if(ctx){ ensureSynths(); applyBassParams(false); } scheduleSave(); });
      bindInput(resEl, ()=>{ if(ctx){ ensureSynths(); applyBassParams(false); } scheduleSave(); });
      bindInput(envEl, ()=>{ scheduleSave(); });
      bindInput(bDecayEl, ()=>{ scheduleSave(); });
      bindInput(dMixEl, ()=>{ if(ctx){ ensureSynths(); bassDelayFX.update(false); } scheduleSave(); });
      bindInput(dFbEl,  ()=>{ if(ctx){ ensureSynths(); bassDelayFX.update(false); } scheduleSave(); });

      bindInput(lCutEl, ()=>{ if(ctx){ ensureSynths(); applyLeadParams(false); } scheduleSave(); });
      bindInput(lResEl, ()=>{ if(ctx){ ensureSynths(); applyLeadParams(false); } scheduleSave(); });
      bindInput(lEnvEl, ()=>{ scheduleSave(); });
      bindInput(lGateEl, ()=>{ scheduleSave(); });
      bindInput(lMixEl, ()=>{ if(ctx){ ensureSynths(); leadDelayFX.update(false); } scheduleSave(); });
      bindInput(lFbEl,  ()=>{ if(ctx){ ensureSynths(); leadDelayFX.update(false); } scheduleSave(); });

      function stepToFreq(kind, stepIndex){
        const st = (kind==="bass") ? bassState.steps[stepIndex] : leadState.steps[stepIndex];
        if(!st.note) return null;

        const baseOct = (kind==="bass") ? 2 : 5;
        const semi = NOTE_TO_SEMI[st.note] ?? 0;
        const midi = (baseOct*12) + semi + (st.oct*12);
        return 440 * Math.pow(2, (midi - 69) / 12);
      }

      function playBassNoteNow(stepIndex){
        if(!ctx) return;
        ensureSynths();
        const f = stepToFreq("bass", stepIndex);
        if(!f) return;

        const t = ctx.currentTime;
        bassSynth.trigger({
          freq:f,
          time:t,
          decay:(+bDecayEl.value || 0.28),
          gate:0.62,                    // a bit smoother sustain
          envAmt:(+envEl.value || 0.32),
          baseCut01:(+cutEl.value),
          release:0.12,
          vel:1.0
        });
      }

      function playLeadNoteNow(stepIndex){
        if(!ctx) return;
        ensureSynths();
        const f = stepToFreq("lead", stepIndex);
        if(!f) return;

        const t = ctx.currentTime;
        leadSynth.trigger({
          freq:f,
          time:t,
          decay:0.16,
          gate:(+lGateEl.value || 0.55),
          envAmt:(+lEnvEl.value || 0.40),
          baseCut01:(+lCutEl.value),
          release:0.34,                // more release, mellow
          vel:0.88
        });
      }

      // Scheduling bass/lead
      let bassIsRunning=false, bassStep=0, bassNextTime=0, bassTimer=null;
      let leadIsRunning=false, leadStep=0, leadNextTime=0, leadTimer=null;

      function bassSchedule(stepIndex, time){
        const f = stepToFreq("bass", stepIndex);
        if(!f) return;
        ensureSynths();
        bassSynth.trigger({
          freq:f,
          time:time,
          decay:(+bDecayEl.value || 0.28),
          gate:0.62,
          envAmt:(+envEl.value || 0.32),
          baseCut01:(+cutEl.value),
          release:0.12,
          vel:1.0
        });
      }

      function leadSchedule(stepIndex, time){
        const f = stepToFreq("lead", stepIndex);
        if(!f) return;
        ensureSynths();
        leadSynth.trigger({
          freq:f,
          time:time,
          decay:0.16,
          gate:(+lGateEl.value || 0.55),
          envAmt:(+lEnvEl.value || 0.40),
          baseCut01:(+lCutEl.value),
          release:0.34,
          vel:0.88
        });
      }

      function bassScheduler(){
        if(!bassIsRunning) return;
        const base = eighthSec(); // bass = 1/8
        while(bassNextTime < ctx.currentTime + AHEAD_SEC){
          bassSchedule(bassStep, bassNextTime);
          bassStep = (bassStep + 1) % 8;
          bassNextTime += base;
        }
        bassTimer = setTimeout(bassScheduler, LOOKAHEAD_MS);
      }

      function leadScheduler(){
        if(!leadIsRunning) return;
        const base = sixteenthSec(); // lead = 2× sneller
        while(leadNextTime < ctx.currentTime + AHEAD_SEC){
          leadSchedule(leadStep, leadNextTime);
          leadStep = (leadStep + 1) % 8;
          leadNextTime += base;
        }
        leadTimer = setTimeout(leadScheduler, LOOKAHEAD_MS);
      }

      function bassStart(t0){
        bassIsRunning = true;
        bassStep = 0;
        bassNextTime = t0;
        if(bassTimer) clearTimeout(bassTimer);
        bassScheduler();
      }
      function leadStart(t0){
        leadIsRunning = true;
        leadStep = 0;
        leadNextTime = t0;
        if(leadTimer) clearTimeout(leadTimer);
        leadScheduler();
      }
      function bassStop(){
        bassIsRunning=false;
        if(bassTimer) clearTimeout(bassTimer);
        bassTimer=null;
      }
      function leadStop(){
        leadIsRunning=false;
        if(leadTimer) clearTimeout(leadTimer);
        leadTimer=null;
      }

      // Reset buttons
      bassResetBtn.addEventListener("click", ()=>{
        bassState = makeSeqState();
        renderSeqGrid(tbGridEl, bassState, "bass");
        scheduleSave();
      });
      leadResetBtn.addEventListener("click", ()=>{
        leadState = makeSeqState();
        renderSeqGrid(leadGridEl, leadState, "lead");
        scheduleSave();
      });

      // -----------------
      // Transport (play/stop all)
      // -----------------
      let isPlaying=false;

      async function masterPlay(){
        await resumeAudio();
        ensureSynths();
        applyBassParams(true);
        applyLeadParams(true);
        applyMixerNow(true);

        const t0 = ctx.currentTime + 0.06;
        sharedStartTime = t0;

        const ok = drumStart(t0);
        if(!ok) return;

        bassStart(t0);
        leadStart(t0);

        isPlaying = true;
        masterPlayBtn.disabled = true;
        masterStopBtn.disabled = false;
        setStatus("Playing");
      }

      function masterStop(){
        drumStop();
        bassStop();
        leadStop();

        isPlaying = false;
        masterPlayBtn.disabled = false;
        masterStopBtn.disabled = true;
        setStatus("Stopped");
      }

      masterPlayBtn.addEventListener("click", masterPlay);
      masterStopBtn.addEventListener("click", masterStop);

      // -----------------
      // Master recording (1 minute) -> Export WAV + countdown 60..0
      // -----------------
      const recBtn = document.getElementById("recBtn");
      const recStopBtn = document.getElementById("recStopBtn");
      const recExportBtn = document.getElementById("recExportBtn");

      function wavFromFloat32(chL, chR, sampleRate){
        const n = Math.min(chL.length, chR.length);
        const bytesPerSample = 2;
        const blockAlign = 2 * bytesPerSample;
        const byteRate = sampleRate * blockAlign;
        const dataSize = n * blockAlign;

        const buffer = new ArrayBuffer(44 + dataSize);
        const view = new DataView(buffer);

        function writeStr(off, s){
          for(let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));
        }

        writeStr(0, "RIFF");
        view.setUint32(4, 36 + dataSize, true);
        writeStr(8, "WAVE");

        writeStr(12, "fmt ");
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 2, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, 16, true);

        writeStr(36, "data");
        view.setUint32(40, dataSize, true);

        let o = 44;
        for(let i=0;i<n;i++){
          const l = clamp(chL[i], -1, 1);
          const r = clamp(chR[i], -1, 1);
          view.setInt16(o, Math.round(l * 32767), true); o += 2;
          view.setInt16(o, Math.round(r * 32767), true); o += 2;
        }
        return new Blob([buffer], { type:"audio/wav" });
      }

      function startCountdown(){
        recRemaining = 60;
        statusRight.textContent = `⏺ ${recRemaining}s`;
        if(recTick) clearInterval(recTick);
        recTick = setInterval(()=>{
          recRemaining = Math.max(0, recRemaining - 1);
          statusRight.textContent = `⏺ ${recRemaining}s`;
          if(recRemaining <= 0){
            clearInterval(recTick);
            recTick = null;
          }
        }, 1000);
      }

      function stopCountdown(){
        if(recTick){ clearInterval(recTick); recTick = null; }
        statusRight.textContent = "";
      }

      function startMasterRecord(){
        if(!ctx || !recDest) return;
        if(mediaRec && mediaRec.state === "recording") return;

        try{
          recChunks = [];
          recBlob = null;

          mediaRec = new MediaRecorder(recDest.stream);
          mediaRec.ondataavailable = (e)=>{ if(e.data && e.data.size) recChunks.push(e.data); };
          mediaRec.onstop = async ()=>{
            stopCountdown();
            try{
              recBlob = new Blob(recChunks, { type: mediaRec.mimeType || "audio/webm" });
              recExportBtn.disabled = false;
              setStatus("Recorded ✅ (export klaar)");
            }catch(err){
              console.error(err);
              setStatus("Record failed");
            }
          };

          mediaRec.start();
          setStatus("Recording… (max 1:00)");
          startCountdown();

          recBtn.disabled = true;
          recStopBtn.disabled = false;
          recExportBtn.disabled = true;

          recTimeout = setTimeout(()=>stopMasterRecord(), 60000);
        }catch(err){
          console.error(err);
          setStatus("Recording not supported");
        }
      }

      function stopMasterRecord(){
        if(recTimeout){ clearTimeout(recTimeout); recTimeout=null; }
        if(mediaRec && mediaRec.state === "recording"){
          try{ mediaRec.stop(); }catch(_){}
        }
        recBtn.disabled = false;
        recStopBtn.disabled = true;
      }

      async function exportMasterWav(){
        if(!recBlob || !ctx) return;

        try{
          const arr = await recBlob.arrayBuffer();
          const abuf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));

          const chL = abuf.getChannelData(0);
          const chR = (abuf.numberOfChannels > 1) ? abuf.getChannelData(1) : abuf.getChannelData(0);

          const wav = wavFromFloat32(chL, chR, abuf.sampleRate);

          const a = document.createElement("a");
          a.href = URL.createObjectURL(wav);
          a.download = "master_recording.wav";
          document.body.appendChild(a);
          a.click();
          a.remove();

          setStatus("WAV exported ✅");
        }catch(err){
          console.error(err);
          setStatus("Export failed");
        }
      }

      recBtn.addEventListener("click", async ()=>{
        await resumeAudio();
        startMasterRecord();
      });
      recStopBtn.addEventListener("click", stopMasterRecord);
      recExportBtn.addEventListener("click", exportMasterWav);

      // -----------------
      // Save/Load state
      // -----------------
      function gatherState(){
        return {
          tempo: tempo(),
          masterVol: +masterVol.value,
          sidechain: sideAmt(),
          tracks: tracks.map(t=>({ key:t.key, pattern:[...t.pattern] })),
          bass: bassState,
          lead: leadState,
          params:{
            cut:+cutEl.value, res:+resEl.value, env:+envEl.value, bDecay:+bDecayEl.value, dMix:+dMixEl.value, dFb:+dFbEl.value,
            lCut:+lCutEl.value, lRes:+lResEl.value, lEnv:+lEnvEl.value, lGate:+lGateEl.value, lMix:+lMixEl.value, lFb:+lFbEl.value,
            m:{
              dV:+mDrumVolEl.value, bV:+mBassVolEl.value, lV:+mLeadVolEl.value,
              dF:+mDrumLPFEl.value, bF:+mBassLPFEl.value, lF:+mLeadLPFEl.value,
              dm:mute.drums, bm:mute.bass, lm:mute.lead
            }
          }
        };
      }

      function applyState(st){
        try{
          if(!st) return;

          if(st.tempo) tempoEl.value = String(clamp(st.tempo,80,160));
          tempoVal.textContent = String(tempo());

          if(typeof st.masterVol === "number") masterVol.value = String(clamp(st.masterVol,0,1));
          if(typeof st.sidechain === "number"){
            sidechainAmtEl.value = String(clamp(st.sidechain,0,1));
            sidechainValEl.textContent = (+sidechainAmtEl.value).toFixed(2);
          }

          if(Array.isArray(st.tracks)){
            for(const savedTr of st.tracks){
              const tr = tracks.find(x=>x.key===savedTr.key);
              if(tr && Array.isArray(savedTr.pattern) && savedTr.pattern.length===16){
                tr.pattern = savedTr.pattern.map(Boolean);
              }
            }
          }

          if(st.bass && st.bass.steps && st.bass.steps.length===8) bassState = st.bass;
          if(st.lead && st.lead.steps && st.lead.steps.length===8) leadState = st.lead;

          if(st.params){
            if(typeof st.params.cut==="number") cutEl.value = String(clamp(st.params.cut,0,1));
            if(typeof st.params.res==="number") resEl.value = String(clamp(st.params.res,0,1));
            if(typeof st.params.env==="number") envEl.value = String(clamp(st.params.env,0,1));
            if(typeof st.params.bDecay==="number") bDecayEl.value = String(clamp(st.params.bDecay,0.08,0.60));
            if(typeof st.params.dMix==="number") dMixEl.value = String(clamp(st.params.dMix,0,1));
            if(typeof st.params.dFb==="number") dFbEl.value = String(clamp(st.params.dFb,0,0.75));

            if(typeof st.params.lCut==="number") lCutEl.value = String(clamp(st.params.lCut,0,1));
            if(typeof st.params.lRes==="number") lResEl.value = String(clamp(st.params.lRes,0,1));
            if(typeof st.params.lEnv==="number") lEnvEl.value = String(clamp(st.params.lEnv,0,1));
            if(typeof st.params.lGate==="number") lGateEl.value = String(clamp(st.params.lGate,0.10,1));
            if(typeof st.params.lMix==="number") lMixEl.value = String(clamp(st.params.lMix,0,1));
            if(typeof st.params.lFb==="number") lFbEl.value = String(clamp(st.params.lFb,0,0.75));

            if(st.params.m){
              mDrumVolEl.value = String(clamp(st.params.m.dV ?? +mDrumVolEl.value,0,1));
              mBassVolEl.value = String(clamp(st.params.m.bV ?? +mBassVolEl.value,0,1));
              mLeadVolEl.value = String(clamp(st.params.m.lV ?? +mLeadVolEl.value,0,1));
              mDrumLPFEl.value = String(clamp(st.params.m.dF ?? +mDrumLPFEl.value,0,1));
              mBassLPFEl.value = String(clamp(st.params.m.bF ?? +mBassLPFEl.value,0,1));
              mLeadLPFEl.value = String(clamp(st.params.m.lF ?? +mLeadLPFEl.value,0,1));

              mute.drums = !!st.params.m.dm;
              mute.bass  = !!st.params.m.bm;
              mute.lead  = !!st.params.m.lm;

              mDrumMuteBtn.classList.toggle("on", mute.drums);
              mBassMuteBtn.classList.toggle("on", mute.bass);
              mLeadMuteBtn.classList.toggle("on", mute.lead);
              mDrumMuteBtn.textContent = mute.drums ? "Muted" : "Mute";
              mBassMuteBtn.textContent = mute.bass ? "Muted" : "Mute";
              mLeadMuteBtn.textContent = mute.lead ? "Muted" : "Mute";
            }
          }

          renderDrum();
          renderSeqGrid(tbGridEl, bassState, "bass");
          renderSeqGrid(leadGridEl, leadState, "lead");
        }catch(err){
          console.error(err);
        }
      }

      // -----------------
      // Init
      // -----------------
      hookMixer();
      buildHeader();
      renderDrum();
      renderSeqGrid(tbGridEl, bassState, "bass");
      renderSeqGrid(leadGridEl, leadState, "lead");

      loadAllSounds();

      const saved = loadSaved();
      if(saved){
        applyState(saved);
        setStatus("Autosave loaded ✅");
      }else{
        setStatus("Ready");
      }

      // (Save/Load file buttons still not implemented here)
    })();
  </script>
</body>
</html>
