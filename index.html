<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Drum Machine + Bassline + Trance Lead + Mixer</title>
  <style>
    :root{
      --bg:#ffffff;
      --card:#ffffff;
      --border:#d9d9d9;
      --text:#111;
      --muted:#666;

      --gridBorder:#cfcfcf;
      --cellA:#fff;
      --cellB:#f3f3f3;
      --playhead: rgba(0,0,0,.14);

      --t1:hsl(10 85% 72%);
      --t2:hsl(90 70% 72%);
      --t3:hsl(200 80% 72%);
      --t4:hsl(280 75% 76%);
      --t5:hsl(45 90% 72%);
      --t6:hsl(160 70% 72%);
      --t7:hsl(210 85% 78%);
      --t8:hsl(330 75% 78%);

      --noteGrey:#e6e6e6;
      --noteNat:#ffffff;

      /* ✅ kleuren voor on-pads + octave selectie */
      --bassOn:#7f1d1d;   /* diepe rood */
      --leadOn:#6d28d9;   /* paars */

      --headerH:64px;
      --footerH:40px;
      --gap:12px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      overflow:hidden;
    }

    header{
      height:var(--headerH);
      position:sticky; top:0; z-index:50;
      background:#fff;
      border-bottom:1px solid var(--border);
      padding:10px 12px;
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:10px;
    }
    .topLeft,.topRight{display:flex;align-items:center;gap:10px}
    .topLeft{justify-content:flex-start}
    .topMid{display:flex;justify-content:center;gap:10px}
    .topRight{display:flex;justify-content:flex-end;gap:10px}

    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background:#fff;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .pill strong{color:var(--text);font-weight:950}
    input[type="range"]{accent-color:#111}
    .tempoRange{width:220px}

    button{
      border:1px solid var(--border);
      background:#fff;
      height:40px;
      padding:0 16px;
      border-radius:14px;
      cursor:pointer;
      font-weight:950;
      font-size:15px;
      white-space:nowrap;
      touch-action:manipulation;
    }
    button.primary{background:#111;color:#fff;border-color:#111}
    button:disabled{opacity:.55;cursor:not-allowed}

    .wrap{
      padding:var(--gap);
      height:calc(100vh - var(--headerH) - var(--footerH));
      display:grid;
      grid-template-columns: 1.25fr 1fr 1fr 0.9fr;
      gap:var(--gap);
      align-items:stretch;
      min-height:0;
    }

    .card{
      border:1px solid var(--border);
      border-radius:18px;
      background:#fff;
      box-shadow:0 10px 28px rgba(0,0,0,.06);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .cardHead{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex:0 0 auto;
    }
    .title{
      font-size:16px;
      font-weight:1000;
      letter-spacing:.2px;
    }
    .smallBtn{
      height:34px;
      padding:0 12px;
      border-radius:12px;
      font-size:13px;
      font-weight:900;
    }

    .body{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      flex:1 1 auto;
      min-height:0;
    }

    /* DRUM tools */
    .drumToolsCompact{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      align-items:center;
      justify-content:flex-end;
    }
    .drumToolsCompact .smallBtn{ height:32px; padding:0 10px; font-size:12px; border-radius:11px; }

    .samplerBar{
      display:flex;
      gap:6px;
      align-items:center;
      padding:6px 8px;
      border:1px solid var(--border);
      border-radius:14px;
      background:#fff;
      flex-wrap:wrap;
      flex:0 0 auto;
    }
    .samplerStatus{
      font-size:12px;
      font-weight:950;
      color:var(--muted);
      white-space:nowrap;
      max-width:140px;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .samplerKnob{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border:1px solid var(--border);
      border-radius:999px;
      background:#fff;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      height:32px;
    }
    .samplerKnob input[type="range"]{width:78px}
    #s1PitchVal,#s2PitchVal{
      display:inline-block;
      width:3ch;
      text-align:center;
      font-variant-numeric:tabular-nums;
    }

    /* DRUM GRID */
    .gridWrap{
      border:1px solid var(--gridBorder);
      border-radius:16px;
      overflow:hidden;
      background:#fff;
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
    }
    .headerRow{
      display:grid;
      grid-template-columns: 160px repeat(16,1fr);
      border-bottom:1px solid var(--gridBorder);
      background:#fff;
      flex:0 0 auto;
    }
    .headerCell{
      padding:8px 4px;
      font-size:10px;
      color:var(--muted);
      text-align:center;
      border-left:1px solid var(--gridBorder);
      font-weight:900;
    }
    .headerCell:first-child{
      text-align:left;
      border-left:none;
      padding-left:10px;
    }
    #grid{flex:1 1 auto; min-height:0; overflow:hidden;}
    .row{ display:grid; grid-template-columns: 160px repeat(16,1fr); }
    .row+.row{border-top:1px solid var(--gridBorder)}
    .trackCell{
      display:flex; align-items:center; justify-content:space-between;
      gap:8px; padding:8px 10px;
      border-right:1px solid var(--gridBorder);
      background:#fff;
    }
    .trackLeft{display:flex;align-items:center;gap:8px;min-width:0;flex:1 1 auto}
    .swatch{width:12px;height:12px;border-radius:999px;border:1px solid rgba(0,0,0,.12);flex:0 0 auto}
    .trackText{display:flex;flex-direction:column;min-width:0;gap:1px}
    .trackName{
      font-weight:1000;font-size:12px;color:var(--text);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:92px;line-height:1.1;
    }
    .fileLabel{
      font-size:10px;color:var(--muted);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:92px;
    }
    .mini{display:flex;gap:6px;align-items:center;flex:0 0 auto}
    .mini button{height:30px;padding:0 9px;border-radius:11px;font-size:12px;font-weight:950}
    .cell{
      height:38px;border-left:1px solid var(--gridBorder);
      display:flex;align-items:center;justify-content:center;
      background:var(--cellA);cursor:pointer;touch-action:manipulation;
    }
    .cell.alt{background:var(--cellB)}
    .cell.playhead{outline:4px solid var(--playhead);outline-offset:-4px}
    .cell.on.t1{background:var(--t1)}
    .cell.on.t2{background:var(--t2)}
    .cell.on.t3{background:var(--t3)}
    .cell.on.t4{background:var(--t4)}
    .cell.on.t5{background:var(--t5)}
    .cell.on.t6{background:var(--t6)}
    .cell.on.t7{background:var(--t7)}
    .cell.on.t8{background:var(--t8)}

    .statusLine{
      font-size:12px;color:var(--muted);
      display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;
      flex:0 0 auto;
    }

    /* Bass + Lead controls */
    .seqControls{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
      margin-bottom:6px; flex:0 0 auto;
    }
    .seqControls .pill input[type="range"]{width:120px}

    .tb_grid{
      display:grid;
      grid-template-columns:58px repeat(8, 1fr);
      column-gap:8px;
      align-items:stretch;
      flex:1 1 auto;
      min-height:0;
    }
    .tb_labels,.tb_col{
      display:grid;
      grid-template-rows:18px 50px 10px repeat(12, minmax(18px, 1fr));
      gap:6px;
      height:100%;
      min-height:0;
    }
    .tb_labels{font-size:12px;color:var(--muted);user-select:none}
    .tb_labels .muted{font-size:11px;font-weight:950;letter-spacing:.2px}
    .tb_stepNum{text-align:center;font-size:12px;font-weight:1000;user-select:none}

    /* ✅ Octave knoppen: geen icons, geen cijfers */
    .tb_oct{display:grid;grid-template-rows:repeat(3,1fr);gap:6px;height:50px;margin-bottom:0}
    .tb_octBtn{
      width:100%;height:100%;
      border:1px solid var(--border);
      background:#fff;cursor:pointer;border-radius:8px;touch-action:manipulation;
    }
    .tb_octBtn.on{border-color:transparent}
    .tb_octBtn.bass.on{background:var(--bassOn)}
    .tb_octBtn.lead.on{background:var(--leadOn)}

    .tb_spacer{height:10px;}

    .tb_pad{
      width:100%;height:100%;
      border:1px solid var(--border);
      background:var(--noteGrey);
      cursor:pointer;border-radius:10px;touch-action:manipulation;
    }
    .tb_pad.nat{background:var(--noteNat)}
    .tb_pad.on{border-color:transparent}
    .tb_pad.on.bass{background:var(--bassOn)}
    .tb_pad.on.lead{background:var(--leadOn)}

    /* MIXER */
    .mixerGrid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      align-items:stretch;
      flex:1 1 auto;
      min-height:0;
    }
    .chan{
      border:1px solid var(--border);
      border-radius:16px;
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      background:#fff;
    }
    .chanTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      flex:0 0 auto;
    }
    .chanName{font-weight:1000;font-size:13px;color:var(--text)}
    .muteBtn{
      height:30px;
      padding:0 10px;
      border-radius:12px;
      font-size:12px;
      font-weight:1000;
    }
    .muteBtn.on{background:#111;color:#fff;border-color:#111}

    .faderWrap{
      display:flex;
      gap:10px;
      align-items:flex-end;
      justify-content:space-between;
      flex:1 1 auto;
      min-height:0;
    }
    .faderCol{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      flex:1 1 0;
      min-height:0;
    }
    .faderLabel{font-size:11px;color:var(--muted);font-weight:950}

    .vfaderShell{
      position:relative;
      width:34px;
      height:220px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .vfader{
      -webkit-appearance:none;
      appearance:none;
      width:220px;
      height:34px;
      background:transparent;
      transform: rotate(-90deg);
      display:block;
      margin:0;
      padding:0;
    }
    .vfader:focus{outline:none}

    .vfader::-webkit-slider-runnable-track{
      height:8px;
      border-radius:999px;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.10);
    }
    .vfader::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:26px;
      height:26px;
      border-radius:999px;
      background:#111;
      border:2px solid #111;
      margin-top:-9px;
      cursor:pointer;
    }

    .vfader::-moz-range-track{
      height:8px;
      border-radius:999px;
      background: rgba(0,0,0,.08);
      border: 1px solid rgba(0,0,0,.10);
    }
    .vfader::-moz-range-thumb{
      width:26px;height:26px;border-radius:999px;
      background:#111;border:2px solid #111;
      cursor:pointer;
    }

    footer{
      height:var(--footerH);
      border-top:1px solid var(--border);
      display:grid;
      grid-template-columns: 1.25fr 1fr 1fr 0.9fr;
      gap:var(--gap);
      padding:10px 12px;
      align-items:center;
      color:var(--muted);
      font-size:12px;
    }
    .footerSpacer{grid-column:1 / span 3;}
    .footerRight{
      grid-column:4;
      justify-self:start;
      font-weight:900;
      color:var(--muted);
    }

    @media (max-width:1200px){
      body{overflow:auto}
      .wrap{height:auto;grid-template-columns:1fr;}
      footer{grid-template-columns:1fr;height:auto;}
      .footerSpacer{display:none}
      .footerRight{grid-column:1;justify-self:end}
    }
  </style>
</head>

<body>
  <header>
    <div class="topLeft">
      <div class="pill">
        <span>Tempo</span>
        <input id="tempo" class="tempoRange" type="range" min="80" max="160" value="120">
        <strong id="tempoVal">120</strong>
      </div>
    </div>

    <div class="topMid">
      <button id="masterPlay" class="primary">Play</button>
      <button id="masterStop" disabled>Stop</button>
    </div>

    <div class="topRight">
      <div class="pill">
        <span>Vol</span>
        <input id="masterVol" type="range" min="0" max="1" value="0.9" step="0.01">
      </div>
    </div>
  </header>

  <div class="wrap">
    <!-- DRUM MACHINE -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Drum Machine</div>
        <div class="drumToolsCompact">
          <button id="saveFileBtn" class="smallBtn">Save</button>
          <button id="loadFileBtn" class="smallBtn">Load</button>
          <input id="loadFileInput" type="file" accept=".mmjson,application/json" style="display:none" />
          <button id="clear" class="smallBtn">Clear</button>
        </div>
      </div>

      <div class="body">
        <div class="samplerBar">
          <strong style="font-size:12px">Sample 1</strong>
          <button id="s1RecBtn" class="smallBtn">2s</button>
          <button id="s1PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s1ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s1Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s1Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s1Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s1PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s1Status" class="samplerStatus">No sample</span>
        </div>

        <div class="samplerBar">
          <strong style="font-size:12px">Sample 2</strong>
          <button id="s2RecBtn" class="smallBtn">2s</button>
          <button id="s2PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s2ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s2Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s2Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s2Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s2PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s2Status" class="samplerStatus">No sample</span>
        </div>

        <div class="gridWrap">
          <div class="headerRow" id="headerRow"></div>
          <div id="grid"></div>
        </div>

        <div class="statusLine">
          <div id="statusLeft"></div>
          <div id="statusRight"></div>
        </div>
      </div>
    </div>

    <!-- BASSLINE -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Bassline</div>
        <div></div>
      </div>

      <div class="body">
        <div class="seqControls">
          <button id="bassReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="cutoff" type="range" min="150" max="6500" value="900"></div>
          <div class="pill"><span>Res</span><input id="reso" type="range" min="0" max="1" step="0.01" value="0.30"></div>
          <div class="pill"><span>Env</span><input id="env" type="range" min="0" max="1" step="0.01" value="0.45"></div>
          <div class="pill"><span>Decay</span><input id="bDecay" type="range" min="0.05" max="0.35" step="0.01" value="0.16"></div>

          <!-- ✅ delay 1/8D op bass -->
          <div class="pill"><span>Mix</span><input id="dMix" type="range" min="0" max="1" step="0.01" value="0.18"></div>
          <div class="pill"><span>FB</span><input id="dFb" type="range" min="0" max="0.75" step="0.01" value="0.22"></div>
        </div>

        <div id="tb_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- TRANCE LEAD -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Trance Lead (2×)</div>
        <div></div>
      </div>

      <div class="body">
        <div class="seqControls">
          <button id="leadReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="lCutoff" type="range" min="250" max="11000" value="2600"></div>
          <div class="pill"><span>Res</span><input id="lReso" type="range" min="0" max="1" step="0.01" value="0.22"></div>
          <div class="pill"><span>Env</span><input id="lEnv" type="range" min="0" max="1" step="0.01" value="0.62"></div>
          <div class="pill"><span>Gate</span><input id="lGate" type="range" min="0.10" max="1" step="0.01" value="0.55"></div>

          <!-- ✅ delay 1/8D op lead -->
          <div class="pill"><span>Mix</span><input id="lMix" type="range" min="0" max="1" step="0.01" value="0.16"></div>
          <div class="pill"><span>FB</span><input id="lFb" type="range" min="0" max="0.75" step="0.01" value="0.18"></div>
        </div>

        <div id="lead_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- MIXER -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Mixer</div>
        <div></div>
      </div>

      <div class="body">
        <div class="mixerGrid">
          <!-- Drums -->
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Drums</div>
              <button id="mDrumMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mDrumVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.20">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mDrumLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="0.00">
                </div>
              </div>
            </div>
          </div>

          <!-- Bass -->
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Bass</div>
              <button id="mBassMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mBassVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.10">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mBassLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="0.00">
                </div>
              </div>
            </div>
          </div>

          <!-- Lead -->
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Lead</div>
              <button id="mLeadMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mLeadVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.32">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mLeadLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="0.00">
                </div>
              </div>
            </div>
          </div>
        </div>

        <div style="font-size:12px;color:var(--muted);font-weight:900;line-height:1.2">
          Tip: Vol fader: beneden = stil, boven = 0 dB (unity). LPF: beneden = dicht (≈0 Hz), boven = open.
        </div>
      </div>
    </div>

  </div>

  <footer>
    <div class="footerSpacer"></div>
    <div class="footerRight">Muziek met meester Luis 2026</div>
  </footer>

  <script>
    (() => {
      "use strict";

      // ---------- DOM ----------
      const tempoEl = document.getElementById("tempo");
      const tempoVal = document.getElementById("tempoVal");
      const masterVol = document.getElementById("masterVol");
      const masterPlayBtn = document.getElementById("masterPlay");
      const masterStopBtn = document.getElementById("masterStop");

      const saveFileBtn = document.getElementById("saveFileBtn");
      const loadFileBtn = document.getElementById("loadFileBtn");
      const loadFileInput = document.getElementById("loadFileInput");

      const statusLeft  = document.getElementById("statusLeft");
      const statusRight = document.getElementById("statusRight");
      const clearBtn    = document.getElementById("clear");

      const headerRow = document.getElementById("headerRow");
      const gridEl    = document.getElementById("grid");

      const s1RecBtn   = document.getElementById("s1RecBtn");
      const s1PlayBtn  = document.getElementById("s1PlayBtn");
      const s1ClearBtn = document.getElementById("s1ClearBtn");
      const s1Status   = document.getElementById("s1Status");
      const s1MixEl    = document.getElementById("s1Mix");
      const s1FbEl     = document.getElementById("s1Fb");
      const s1PitchEl  = document.getElementById("s1Pitch");
      const s1PitchVal = document.getElementById("s1PitchVal");

      const s2RecBtn   = document.getElementById("s2RecBtn");
      const s2PlayBtn  = document.getElementById("s2PlayBtn");
      const s2ClearBtn = document.getElementById("s2ClearBtn");
      const s2Status   = document.getElementById("s2Status");
      const s2MixEl    = document.getElementById("s2Mix");
      const s2FbEl     = document.getElementById("s2Fb");
      const s2PitchEl  = document.getElementById("s2Pitch");
      const s2PitchVal = document.getElementById("s2PitchVal");

      const bassResetBtn = document.getElementById("bassReset");
      const leadResetBtn = document.getElementById("leadReset");

      const cutEl = document.getElementById("cutoff");
      const resEl = document.getElementById("reso");
      const envEl = document.getElementById("env");
      const bDecayEl = document.getElementById("bDecay");
      const dMixEl = document.getElementById("dMix");
      const dFbEl  = document.getElementById("dFb");

      const lCutEl = document.getElementById("lCutoff");
      const lResEl = document.getElementById("lReso");
      const lEnvEl = document.getElementById("lEnv");
      const lGateEl= document.getElementById("lGate");
      const lMixEl = document.getElementById("lMix");
      const lFbEl  = document.getElementById("lFb");

      const mDrumVolEl = document.getElementById("mDrumVol");
      const mBassVolEl = document.getElementById("mBassVol");
      const mLeadVolEl = document.getElementById("mLeadVol");

      const mDrumLPFEl = document.getElementById("mDrumLPF");
      const mBassLPFEl = document.getElementById("mBassLPF");
      const mLeadLPFEl = document.getElementById("mLeadLPF");

      const mDrumMuteBtn = document.getElementById("mDrumMute");
      const mBassMuteBtn = document.getElementById("mBassMute");
      const mLeadMuteBtn = document.getElementById("mLeadMute");

      const tbGridEl = document.getElementById("tb_grid");
      const leadGridEl = document.getElementById("lead_grid");

      // ---------- helpers ----------
      function safeJSONParse(s){ try{ return JSON.parse(s); }catch(_){ return null; } }
      function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
      function tempo(){ return clamp(parseFloat(tempoEl.value||120), 80, 160); }
      function quarterSec(){ return 60/tempo(); }
      function eighthSec(){ return quarterSec()/2; }
      function dottedEighthSec(){ return eighthSec()*1.5; } // ✅ 1/8D
      function sixteenthSec(){ return quarterSec()/4; }
      function setStatus(t){ statusLeft.textContent = t || ""; }

      function expMap01(x, minHz, maxHz){
        x = clamp(x, 0, 1);
        const a = Math.log(minHz);
        const b = Math.log(maxHz);
        return Math.exp(a + (b-a)*x);
      }
      function bindInput(el, fn){
        el.addEventListener("input", fn, { passive:true });
        el.addEventListener("change", fn, { passive:true });
      }
      function sampleRateFromSemis(semis){ return Math.pow(2, (semis/12)); }
      function fmtPitch(v){
        v = Math.max(-12, Math.min(12, (v|0)));
        const sign = (v >= 0) ? "+" : "-";
        const n = String(Math.abs(v)).padStart(2,"0");
        return sign + n;
      }
      function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

      // ---------- autosave ----------
      const STORE_KEY = "mm_drum_bass_lead_mixer_v2_full";
      let saveTimer = null;
      let dirty = false;
      function markDirty(){ dirty = true; }
      function scheduleSave(){
        markDirty();
        clearTimeout(saveTimer);
        saveTimer = setTimeout(saveNow, 200);
      }
      function saveNow(){
        try{
          localStorage.setItem(STORE_KEY, JSON.stringify(gatherState()));
          dirty = false;
        }catch(_){}
      }
      function loadSaved(){
        const raw = localStorage.getItem(STORE_KEY);
        return raw ? safeJSONParse(raw) : null;
      }
      window.addEventListener("beforeunload", ()=>{ if(dirty) saveNow(); });
      setInterval(()=>{ if(dirty) saveNow(); }, 2000);

      // ---------- audio ----------
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      let ctx = null;

      let master = null;
      let drumBus=null, bassBus=null, leadBus=null;
      let drumGain=null, bassGain=null, leadGain=null;
      let drumLPF=null, bassLPF=null, leadLPF=null;

      function ensureAudio(){
        if(ctx) return;
        ctx = new AudioCtx();

        master = ctx.createGain();
        master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);

        drumBus = ctx.createGain();
        bassBus = ctx.createGain();
        leadBus = ctx.createGain();

        drumLPF = ctx.createBiquadFilter(); drumLPF.type="lowpass";
        bassLPF = ctx.createBiquadFilter(); bassLPF.type="lowpass";
        leadLPF = ctx.createBiquadFilter(); leadLPF.type="lowpass";

        drumGain = ctx.createGain();
        bassGain = ctx.createGain();
        leadGain = ctx.createGain();

        drumBus.connect(drumLPF); drumLPF.connect(drumGain); drumGain.connect(master);
        bassBus.connect(bassLPF); bassLPF.connect(bassGain); bassGain.connect(master);
        leadBus.connect(leadLPF); leadLPF.connect(leadGain); leadGain.connect(master);

        const hp = ctx.createBiquadFilter();
        hp.type = "highpass";
        hp.frequency.value = 25;

        master.connect(hp);
        hp.connect(ctx.destination);

        ensureFX();
        applyMixerNow(true);
      }
      async function resumeAudio(){
        ensureAudio();
        try{ await ctx.resume(); }catch(_){}
      }

      bindInput(masterVol, ()=>{
        if(master) master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);
        scheduleSave();
      });
      bindInput(tempoEl, ()=>{
        tempoVal.textContent = String(tempo());
        if(ctx){
          if(s1FX) s1FX.update(false);
          if(s2FX) s2FX.update(false);
          if(bassDelayFX) bassDelayFX.update(false);
          if(leadDelayFX) leadDelayFX.update(false);
        }
        scheduleSave();
      });
      tempoVal.textContent = String(tempo());

      // ---------- mixer ----------
      const mute = { drums:false, bass:false, lead:false };

      function volFromFader(v){
        v = clamp(+v||0, 0, 1);
        return v;
      }

      // ✅ LPF: beneden = dicht (≈0 Hz), boven = open
      function cutoffFromLPFFader(v){
        v = clamp(+v||0, 0, 1);
        return expMap01(v, 60, 20000);
      }

      function applyMixerNow(instant=false){
        if(!ctx) return;
        const t = ctx.currentTime;
        const tau = instant ? 0.001 : 0.02;

        const drumVol = mute.drums ? 0 : volFromFader(mDrumVolEl.value);
        const bassVol = mute.bass ? 0 : volFromFader(mBassVolEl.value);
        const leadVol = mute.lead ? 0 : volFromFader(mLeadVolEl.value);

        const drumCut = cutoffFromLPFFader(mDrumLPFEl.value);
        const bassCut = cutoffFromLPFFader(mBassLPFEl.value);
        const leadCut = cutoffFromLPFFader(mLeadLPFEl.value);

        drumGain.gain.setTargetAtTime(drumVol, t, tau);
        bassGain.gain.setTargetAtTime(bassVol, t, tau);
        leadGain.gain.setTargetAtTime(leadVol, t, tau);

        drumLPF.frequency.setTargetAtTime(drumCut, t, tau);
        bassLPF.frequency.setTargetAtTime(bassCut, t, tau);
        leadLPF.frequency.setTargetAtTime(leadCut, t, tau);

        drumLPF.Q.setTargetAtTime(0.6, t, tau);
        bassLPF.Q.setTargetAtTime(0.7, t, tau);
        leadLPF.Q.setTargetAtTime(0.6, t, tau);
      }

      function hookMixer(){
        const mixerUpdate = ()=>{
          if(ctx) applyMixerNow(false);
          scheduleSave();
        };
        [mDrumVolEl,mBassVolEl,mLeadVolEl,mDrumLPFEl,mBassLPFEl,mLeadLPFEl].forEach(el=>{
          bindInput(el, mixerUpdate);
        });

        function toggleMute(which, btn){
          mute[which] = !mute[which];
          btn.classList.toggle("on", mute[which]);
          btn.textContent = mute[which] ? "Muted" : "Mute";
          if(ctx) applyMixerNow(false);
          scheduleSave();
        }
        mDrumMuteBtn.addEventListener("click", ()=>toggleMute("drums", mDrumMuteBtn));
        mBassMuteBtn.addEventListener("click", ()=>toggleMute("bass", mBassMuteBtn));
        mLeadMuteBtn.addEventListener("click", ()=>toggleMute("lead", mLeadMuteBtn));
      }
      hookMixer();

      // ---------- Delay FX helper ----------
      function makeDelayFX({ mixEl, fbEl }, destBus, kind="eighthD"){
        const dry = ctx.createGain();
        const wetIn = ctx.createGain();
        const delay = ctx.createDelay(2.0);
        const fb = ctx.createGain();
        const wetOut = ctx.createGain();

        wetIn.connect(delay);
        delay.connect(wetOut);
        wetOut.connect(destBus);

        delay.connect(fb);
        fb.connect(delay);

        dry.connect(destBus);

        function update(instant=false){
          const t = ctx.currentTime;
          const dt = (kind==="eighthD") ? dottedEighthSec() : quarterSec();
          const mix = clamp(parseFloat(mixEl.value||0), 0, 1);
          const fbb = clamp(parseFloat(fbEl.value||0), 0, 0.75);
          const tau = instant ? 0.001 : 0.02;

          delay.delayTime.setTargetAtTime(dt, t, tau);
          fb.gain.setTargetAtTime(fbb, t, tau);

          dry.gain.setTargetAtTime(1 - mix, t, tau);
          wetIn.gain.setTargetAtTime(mix, t, tau);
        }

        update(true);
        return { dry, wetIn, update };
      }

      // ---------- Drum machine ----------
      const STEPS = 16;
      const activeSources = new Set();

      const TRACKS_DEF = [
        { name:"Kick",     key:"kick",     colorClass:"t1" },
        { name:"Snare",    key:"snare",    colorClass:"t2" },
        { name:"Hat",      key:"hat",      colorClass:"t3" },
        { name:"OpenHat",  key:"openhat",  colorClass:"t7" },
        { name:"Clap",     key:"clap",     colorClass:"t4" },
        { name:"Perc",     key:"perc",     colorClass:"t5" },
        { name:"Sample 1", key:"sample1",  colorClass:"t6", isSampler:true, samplerId:1 },
        { name:"Sample 2", key:"sample2",  colorClass:"t8", isSampler:true, samplerId:2 },
      ];

      let tracks = TRACKS_DEF.map(t => ({
        ...t,
        fileLabel: t.isSampler ? "No sample" : "Loading…",
        buffer: null,
        pattern: Array(STEPS).fill(false),
      }));

      const sample1Track = tracks.find(t => t.key === "sample1");
      const sample2Track = tracks.find(t => t.key === "sample2");

      function playBufferAt(buf, time, destination){
        if(!ctx || !destination || !buf) return;
        const src = ctx.createBufferSource();
        src.buffer = buf;
        src.connect(destination);

        activeSources.add(src);
        src.onended = () => activeSources.delete(src);

        try{ src.start(time); }catch(_){}
        return src;
      }

      function hardStopAllSources(){
        for(const src of Array.from(activeSources)){
          try{ src.stop(0); }catch(_){}
          activeSources.delete(src);
        }
      }

      function applyTinyFade(buf, fadeMs = 2){
        if(!buf || !ctx) return buf;
        const sr = buf.sampleRate;
        const n = Math.max(1, Math.floor(sr * (fadeMs/1000)));
        for(let c=0;c<buf.numberOfChannels;c++){
          const d = buf.getChannelData(c);
          const L = d.length;
          const nn = Math.min(n, Math.floor(L/2));
          for(let i=0;i<nn;i++){
            const g = (nn<=1) ? 1 : (i/(nn-1));
            d[i] *= g;
            d[L-1-i] *= g;
          }
        }
        return buf;
      }

      function trimBufferPrecise(buf, {
        thr = 0.018,
        minRunMs = 2.0,
        prerollMs = 6.0,
        tailThr = 0.012,
        tailHoldMs = 25.0
      } = {}){
        const sr = buf.sampleRate;
        const len = buf.length;
        const ch0 = buf.getChannelData(0);

        const minRun = Math.max(1, Math.floor(sr * (minRunMs/1000)));
        const preroll = Math.floor(sr * (prerollMs/1000));
        const tailHold = Math.max(1, Math.floor(sr * (tailHoldMs/1000)));

        let start = 0, run = 0, found = false;
        for(let i=0;i<len;i++){
          const a = Math.abs(ch0[i]);
          if(a >= thr){
            run++;
            if(run >= minRun){
              start = Math.max(0, i - run + 1 - preroll);
              found = true;
              break;
            }
          }else run = 0;
        }
        if(!found) return buf;

        let end = len;
        let quietRun = 0;
        for(let i=len-1;i>=0;i--){
          const a = Math.abs(ch0[i]);
          if(a < tailThr){
            quietRun++;
            if(quietRun >= tailHold){
              end = Math.min(len, i + quietRun);
              break;
            }
          }else quietRun = 0;
        }

        const minKeep = Math.floor(sr * 0.06);
        if(end - start < minKeep) end = Math.min(len, start + minKeep);

        start = Math.max(0, Math.min(start, len-1));
        end = Math.max(start+1, Math.min(end, len));

        const outLen = end - start;
        const out = ctx.createBuffer(buf.numberOfChannels, outLen, sr);
        for(let c=0;c<buf.numberOfChannels;c++){
          const src = buf.getChannelData(c);
          const dst = out.getChannelData(c);
          dst.set(src.subarray(start, end));
        }
        return out;
      }

      // ---------- sample delay fx ----------
      let s1FX=null, s2FX=null;
      let bassDelayFX=null, leadDelayFX=null;

      function ensureFX(){
        if(s1FX && s2FX && bassDelayFX && leadDelayFX) return;
        s1FX = makeDelayFX({ mixEl:s1MixEl, fbEl:s1FbEl }, drumBus, "eighthD");
        s2FX = makeDelayFX({ mixEl:s2MixEl, fbEl:s2FbEl }, drumBus, "eighthD");
        bassDelayFX = makeDelayFX({ mixEl:dMixEl, fbEl:dFbEl }, bassBus, "eighthD"); // ✅ 1/8D
        leadDelayFX = makeDelayFX({ mixEl:lMixEl, fbEl:lFbEl }, leadBus, "eighthD"); // ✅ 1/8D
      }

      function setSamplerUI(which, has){
        const is1 = which === 1;
        const playBtn = is1 ? s1PlayBtn : s2PlayBtn;
        const clrBtn  = is1 ? s1ClearBtn : s2ClearBtn;
        const status  = is1 ? s1Status : s2Status;
        const tr      = is1 ? sample1Track : sample2Track;

        playBtn.disabled = !has;
        clrBtn.disabled  = !has;

        if(!has){
          status.textContent = "No sample";
          tr.fileLabel = "No sample";
        }else{
          status.textContent = "Sample ready ✅";
          tr.fileLabel = "Recorded";
        }
      }
      setSamplerUI(1,false);
      setSamplerUI(2,false);

      let _rec=null, _chunks=[], _stream=null, _recWhich=1;

      async function recordSample2s(which){
        await resumeAudio();
        ensureFX();

        if(!navigator.mediaDevices?.getUserMedia){
          alert("Microfoon werkt niet in deze browser.");
          return;
        }
        if(_rec && _rec.state === "recording") return;

        _recWhich = which;
        (which===1 ? s1Status : s2Status).textContent = "Recording…";
        (which===1 ? s1PlayBtn : s2PlayBtn).disabled = true;
        (which===1 ? s1ClearBtn : s2ClearBtn).disabled = true;

        try{
          _stream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
          });

          _chunks = [];
          _rec = new MediaRecorder(_stream);

          _rec.ondataavailable = (e)=>{
            if(e.data && e.data.size) _chunks.push(e.data);
          };

          _rec.onstop = async ()=>{
            const tr = (_recWhich===1) ? sample1Track : sample2Track;
            try{
              const blob = new Blob(_chunks, { type: _rec.mimeType || "audio/webm" });
              const arr = await blob.arrayBuffer();
              const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
              const trimmed = trimBufferPrecise(buf, {});
              tr.buffer = applyTinyFade(trimmed, 2);
              setSamplerUI(_recWhich, true);
              renderDrum();
              scheduleSave();
            }catch(err){
              console.error(err);
              tr.buffer = null;
              setSamplerUI(_recWhich, false);
              (tr===sample1Track ? s1Status : s2Status).textContent = "Sample failed";
              renderDrum();
            }finally{
              if(_stream) _stream.getTracks().forEach(t=>t.stop());
              _stream = null;
            }
          };

          _rec.start();
          setTimeout(()=>{
            if(_rec && _rec.state === "recording"){
              try{ _rec.stop(); }catch(_){}
            }
          }, 2000);

        }catch(err){
          console.error(err);
          (which===1 ? s1Status : s2Status).textContent = "Mic blocked";
          setSamplerUI(which, false);
        }
      }

      function playSampleNow(which, time){
        const tr = (which===1) ? sample1Track : sample2Track;
        if(!tr.buffer || !ctx) return;

        ensureFX();
        const fx = (which===1) ? s1FX : s2FX;
        fx.update(false);

        const t = (typeof time === "number") ? time : ctx.currentTime;
        const src = ctx.createBufferSource();
        src.buffer = tr.buffer;

        const semis = (which===1 ? (+s1PitchEl.value||0) : (+s2PitchEl.value||0));
        src.playbackRate.setValueAtTime(sampleRateFromSemis(semis), t);

        src.connect(fx.dry);
        src.connect(fx.wetIn);

        activeSources.add(src);
        src.onended = () => activeSources.delete(src);

        try{ src.start(t); }catch(_){}
      }

      function clearSample(which){
        const tr = (which===1) ? sample1Track : sample2Track;
        tr.buffer = null;
        setSamplerUI(which, false);
        renderDrum();
        scheduleSave();
      }

      bindInput(s1PitchEl, ()=>{ s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0); scheduleSave(); });
      bindInput(s2PitchEl, ()=>{ s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0); scheduleSave(); });
      s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0);
      s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0);

      function hookSamplerKnobs(which){
        const mixEl = which===1 ? s1MixEl : s2MixEl;
        const fbEl  = which===1 ? s1FbEl  : s2FbEl;
        bindInput(mixEl, ()=>{ if(ctx){ ensureFX(); (which===1?s1FX:s2FX).update(false); } scheduleSave(); });
        bindInput(fbEl,  ()=>{ if(ctx){ ensureFX(); (which===1?s1FX:s2FX).update(false); } scheduleSave(); });
      }
      hookSamplerKnobs(1);
      hookSamplerKnobs(2);

      s1RecBtn.addEventListener("click", ()=>recordSample2s(1));
      s2RecBtn.addEventListener("click", ()=>recordSample2s(2));
      s1PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(1, ctx.currentTime); });
      s2PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(2, ctx.currentTime); });
      s1ClearBtn.addEventListener("click", ()=>clearSample(1));
      s2ClearBtn.addEventListener("click", ()=>clearSample(2));

      async function fetchArrayBuffer(url){
        const r = await fetch(url, { cache:"no-store" });
        if(!r.ok) throw new Error("HTTP " + r.status);
        return await r.arrayBuffer();
      }

      async function loadOneTrack(tr){
        tr.buffer = null;
        tr.fileLabel = "Missing file";
        for(const ext of ["wav","mp3","ogg"]){
          const url = "./samples/" + tr.key + "." + ext;
          try{
            const arr = await fetchArrayBuffer(url);
            const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
            tr.buffer = buf;
            tr.fileLabel = tr.key + "." + ext;
            return true;
          }catch(_){}
        }
        return false;
      }

      async function loadAllSounds(){
        await resumeAudio();
        setStatus("Loading sounds…");
        renderDrum();

        let ok = 0;
        for(const tr of tracks){
          if(tr.isSampler){
            tr.fileLabel = tr.buffer ? "Recorded" : "No sample";
            continue;
          }
          if(await loadOneTrack(tr)) ok++;
          renderDrum();
        }
        setStatus(ok ? `Ready (${ok}/${tracks.filter(t=>!t.isSampler).length}).` : "No sounds loaded (check ./samples filenames).");
        renderDrum();
      }

      // ---------- Drum UI ----------
      function buildHeader(){
        headerRow.innerHTML = "";
        const left = document.createElement("div");
        left.className = "headerCell";
        left.textContent = "Sounds";
        headerRow.appendChild(left);

        for(let s=0;s<16;s++){
          const d=document.createElement("div");
          d.className="headerCell";
          d.textContent = (s%4===0) ? String((s/4)+1) : "";
          headerRow.appendChild(d);
        }
      }

      function renderDrum(){
        gridEl.innerHTML = "";
        tracks.forEach(tr=>{
          const row=document.createElement("div");
          row.className="row";

          const trackCell=document.createElement("div");
          trackCell.className="trackCell";

          const left=document.createElement("div");
          left.className="trackLeft";

          const sw=document.createElement("div");
          sw.className="swatch";
          sw.style.background = (getComputedStyle(document.documentElement).getPropertyValue(`--${tr.colorClass}`).trim() || "#ccc");
          left.appendChild(sw);

          const text=document.createElement("div");
          text.className="trackText";

          const name=document.createElement("div");
          name.className="trackName";
          name.textContent =
            tr.name +
            (tr.isSampler ? (tr.buffer ? "" : " ") : (tr.buffer ? "" : " ⚠"));

          const file=document.createElement("div");
          file.className="fileLabel";
          file.textContent = tr.fileLabel;

          text.appendChild(name);
          text.appendChild(file);
          left.appendChild(text);

          trackCell.appendChild(left);

          const mini=document.createElement("div");
          mini.className="mini";
          const prev=document.createElement("button");
          prev.textContent="▶";
          prev.className="smallBtn";
          prev.disabled = !tr.buffer;
          prev.addEventListener("click", async ()=>{
            await resumeAudio();
            if(tr.isSampler){
              if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
              if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
            }else{
              playBufferAt(tr.buffer, ctx.currentTime, drumBus);
            }
          });
          mini.appendChild(prev);
          trackCell.appendChild(mini);

          row.appendChild(trackCell);

          for(let s=0;s<16;s++){
            const cell=document.createElement("div");
            cell.className = "cell" + ((((s+1)%2)?" alt":""));
            if(tr.pattern[s]) cell.classList.add("on", tr.colorClass);
            if(isPlaying && s===playStep) cell.classList.add("playhead");

            cell.addEventListener("click", async ()=>{
              tr.pattern[s] = !tr.pattern[s];
              await resumeAudio();

              if(tr.pattern[s]){
                if(tr.isSampler){
                  if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
                  if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
                }else if(tr.buffer){
                  playBufferAt(tr.buffer, ctx.currentTime, drumBus);
                }
              }
              renderDrum();
              scheduleSave();
            });

            row.appendChild(cell);
          }

          gridEl.appendChild(row);
        });
      }

      clearBtn.addEventListener("click", ()=>{
        for(const tr of tracks) tr.pattern.fill(false);
        renderDrum();
        setStatus("");
        scheduleSave();
      });

      // ---------- Bass + Lead sequencers ----------
      const NOTE_NAMES = ["B","A#","A","G#","G","F#","F","E","D#","D","C#","C"]; // ✅ C onderaan
      const NAT = new Set(["C","D","E","F","G","A","B"]);

      const bassState = {
        notes: Array(8).fill(null), // semitone 0..11 (C=0 .. B=11)
        octs:  Array(8).fill(0)     // -1,0,+1
      };
      const leadState = {
        notes: Array(8).fill(null),
        octs:  Array(8).fill(0)
      };

      function renderSeqGrid(rootEl, state, which){
        rootEl.innerHTML = "";

        const labels = document.createElement("div");
        labels.className = "tb_labels";
        labels.innerHTML = `
          <div class="muted" style="padding-left:6px">Step</div>
          <div class="muted" style="padding-left:6px">Oct</div>
          <div class="tb_spacer"></div>
        `;
        for(const n of NOTE_NAMES){
          const d = document.createElement("div");
          d.className = "muted";
          d.style.paddingLeft = "6px";
          d.textContent = n;
          labels.appendChild(d);
        }
        rootEl.appendChild(labels);

        for(let s=0;s<8;s++){
          const col = document.createElement("div");
          col.className = "tb_col";

          const stepNum = document.createElement("div");
          stepNum.className = "tb_stepNum";
          stepNum.textContent = String(s+1);
          col.appendChild(stepNum);

          // octave buttons (top=+1, mid=0, bottom=-1)
          const oct = document.createElement("div");
          oct.className = "tb_oct";

          const btnTop = document.createElement("button");
          btnTop.className = `tb_octBtn ${which}`;
          btnTop.dataset.step = String(s);
          btnTop.dataset.oct = "1";

          const btnMid = document.createElement("button");
          btnMid.className = `tb_octBtn ${which}`;
          btnMid.dataset.step = String(s);
          btnMid.dataset.oct = "0";

          const btnBot = document.createElement("button");
          btnBot.className = `tb_octBtn ${which}`;
          btnBot.dataset.step = String(s);
          btnBot.dataset.oct = "-1";

          [btnTop,btnMid,btnBot].forEach(b=>{
            b.addEventListener("click", ()=>{
              const step = +b.dataset.step;
              const v = +b.dataset.oct;
              state.octs[step] = v;              // ✅ geen rare sprong
              renderSeqGrid(rootEl, state, which);
              scheduleSave();
            });
          });

          const cur = state.octs[s] ?? 0;
          btnTop.classList.toggle("on", cur===1);
          btnMid.classList.toggle("on", cur===0);
          btnBot.classList.toggle("on", cur===-1);

          oct.appendChild(btnTop);
          oct.appendChild(btnMid);
          oct.appendChild(btnBot);
          col.appendChild(oct);

          const sp = document.createElement("div");
          sp.className = "tb_spacer";
          col.appendChild(sp);

          // pads
          for(let i=0;i<12;i++){
            const name = NOTE_NAMES[i];
            const isNat = NAT.has(name);

            // map displayed NOTE_NAMES -> semitone (C=0 ... B=11)
            const semis = (name==="C")?0:(name==="C#")?1:(name==="D")?2:(name==="D#")?3:(name==="E")?4:(name==="F")?5:(name==="F#")?6:(name==="G")?7:(name==="G#")?8:(name==="A")?9:(name==="A#")?10:11;

            const pad = document.createElement("button");
            pad.className = "tb_pad " + (isNat ? "nat" : "");
            pad.dataset.step = String(s);
            pad.dataset.semi = String(semis);

            const on = (state.notes[s] === semis);
            if(on) pad.classList.add("on", which);

            pad.addEventListener("click", async ()=>{
              await resumeAudio();
              const step = +pad.dataset.step;
              const semi = +pad.dataset.semi;

              state.notes[step] = (state.notes[step] === semi) ? null : semi;

              renderSeqGrid(rootEl, state, which);
              scheduleSave();

              // preview
              if(which==="bass") previewBass(step);
              else previewLead(step);
            });

            col.appendChild(pad);
          }

          rootEl.appendChild(col);
        }
      }

      function resetSeq(state){
        state.notes.fill(null);
        state.octs.fill(0);
        scheduleSave();
      }

      bassResetBtn.addEventListener("click", ()=>{
        resetSeq(bassState);
        renderSeqGrid(tbGridEl, bassState, "bass");
      });

      leadResetBtn.addEventListener("click", ()=>{
        resetSeq(leadState);
        renderSeqGrid(leadGridEl, leadState, "lead");
      });

      // ---------- Synth triggers ----------
      function bassCutoffEffective(){
        // ✅ bass cutoff duidelijker: curve + exp-map
        const raw = clamp(parseFloat(cutEl.value||900), 150, 6500);
        const x = (raw - 150) / (6500 - 150);
        const curved = Math.pow(clamp(x,0,1), 2.6);
        return expMap01(curved, 55, 9000);
      }

      function bassQ(){
        const r = clamp(parseFloat(resEl.value||0.30), 0, 1);
        return 0.8 + Math.pow(r, 0.35) * 20.0;
      }

      function triggerBass(time, stepIndex){
        if(!ctx) return;
        const semi = bassState.notes[stepIndex];
        if(semi===null || semi===undefined) return;

        ensureFX();
        bassDelayFX.update(false);

        // ✅ bass lager: C2 basis (was hoger)
        const baseMidi = 36; // C2
        const octShift = bassState.octs[stepIndex] ?? 0;
        const midi = baseMidi + semi + (octShift*12);
        const hz = midiToHz(midi);

        const o = ctx.createOscillator();
        o.type = "sawtooth";
        o.frequency.setValueAtTime(hz, time);

        const f = ctx.createBiquadFilter();
        f.type = "lowpass";

        const g = ctx.createGain();
        g.gain.setValueAtTime(0, time);

        // envelope
        const decay = clamp(parseFloat(bDecayEl.value||0.16), 0.05, 0.35);
        const dur = sixteenthSec() * 2.0; // bass op 8ths (2x 16th)
        const envAmt = clamp(parseFloat(envEl.value||0.45), 0, 1);

        const baseCut = bassCutoffEffective();
        const peakMul = 1 + envAmt * 6.0;
        const peakCut = clamp(baseCut * peakMul, 55, 16000);

        f.Q.setValueAtTime(bassQ(), time);
        f.frequency.setValueAtTime(peakCut, time);
        f.frequency.exponentialRampToValueAtTime(Math.max(55, baseCut), time + Math.max(0.03, decay));

        // amp
        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(0.85, time + 0.002);
        g.gain.exponentialRampToValueAtTime(0.0001, time + dur + 0.08);

        o.connect(f);
        f.connect(g);

        g.connect(bassDelayFX.dry);
        g.connect(bassDelayFX.wetIn);

        o.start(time);
        o.stop(time + dur + 0.12);
      }

      function leadCutoffEffective(){
        const raw = clamp(parseFloat(lCutEl.value||2600), 250, 11000);
        const x = (raw - 250) / (11000 - 250);
        const curved = Math.pow(clamp(x,0,1), 2.4);
        return expMap01(curved, 80, 14000);
      }

      function leadQ(){
        const r = clamp(parseFloat(lResEl.value||0.22), 0, 1);
        return 0.7 + Math.pow(r, 0.35) * 18.0; // responsive
      }

      function triggerLead(time, stepIndex){
        if(!ctx) return;
        const semi = leadState.notes[stepIndex];
        if(semi===null || semi===undefined) return;

        ensureFX();
        leadDelayFX.update(false);

        const baseMidi = 60; // C4
        const octShift = leadState.octs[stepIndex] ?? 0;
        const midi = baseMidi + semi + (octShift*12);
        const hz = midiToHz(midi);

        const o1 = ctx.createOscillator();
        const o2 = ctx.createOscillator();
        o1.type = "sawtooth";
        o2.type = "sawtooth";
        o1.frequency.setValueAtTime(hz, time);
        o2.frequency.setValueAtTime(hz*1.01, time);

        const f = ctx.createBiquadFilter();
        f.type = "lowpass";
        f.Q.setValueAtTime(leadQ(), time);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0, time);

        const gate   = clamp(parseFloat(lGateEl.value||0.55), 0.10, 1);
        const envAmt = clamp(parseFloat(lEnvEl.value||0.62), 0, 1);

        // ✅ cutoff werkt duidelijk
        const baseCut = leadCutoffEffective();
        const peakMul = 1 + envAmt * 7.0;
        const peakCut = clamp(baseCut * peakMul, 120, 20000);

        // timing: lead double-time (1 step per 16th)
        const dur = sixteenthSec() * gate;

        // ✅ meer release
        const rel  = Math.max(0.06, dur * 0.90);
        const tail = 0.12 + rel;

        f.frequency.setValueAtTime(peakCut, time);
        f.frequency.exponentialRampToValueAtTime(Math.max(80, baseCut), time + Math.max(0.03, dur));

        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(0.75, time + 0.003);
        g.gain.exponentialRampToValueAtTime(0.0001, time + dur + tail);

        o1.connect(f);
        o2.connect(f);
        f.connect(g);

        g.connect(leadDelayFX.dry);
        g.connect(leadDelayFX.wetIn);

        o1.start(time);
        o2.start(time);
        o1.stop(time + dur + tail + 0.06);
        o2.stop(time + dur + tail + 0.06);
      }

      // previews
      function previewBass(step){
        if(!ctx) return;
        const t = ctx.currentTime + 0.01;
        triggerBass(t, step);
      }
      function previewLead(step){
        if(!ctx) return;
        const t = ctx.currentTime + 0.01;
        triggerLead(t, step);
      }

      // ---------- transport / scheduler ----------
      const AHEAD_SEC = 0.035;
      const LOOKAHEAD_MS = 15;

      let isPlaying=false;
      let nextTime=0;
      let timer=null;
      let globalStep=0;

      // drum playhead only
      let playStep=0;
      let rafId=null;
      let sharedStartTime=0;

      function scheduleDrumStep(stepIndex,time){
        for(const tr of tracks){
          if(tr.pattern[stepIndex]){
            if(tr.isSampler){
              if(tr.key === "sample1") playSampleNow(1, time);
              else if(tr.key === "sample2") playSampleNow(2, time);
            }else if(tr.buffer){
              playBufferAt(tr.buffer, time, drumBus);
            }
          }
        }
      }

      function scheduler(){
        if(!isPlaying) return;
        const base = sixteenthSec();

        while(nextTime < ctx.currentTime + AHEAD_SEC){
          const step16 = globalStep % 16;

          // drums @16
          scheduleDrumStep(step16, nextTime);

          // bass @8 (elke 2 steps)
          if(step16 % 2 === 0){
            const bStep = (step16/2) % 8;
            triggerBass(nextTime, bStep);
          }

          // lead @double-time: 8 steps maar elke 16th doorlopen
          const lStep = step16 % 8;
          triggerLead(nextTime, lStep);

          globalStep = (globalStep + 1) % 16;
          nextTime += base;
        }

        timer = setTimeout(scheduler, LOOKAHEAD_MS);
      }

      function updatePlayhead(){
        if(!isPlaying) return;
        const base = sixteenthSec();
        const elapsed = ctx.currentTime - sharedStartTime;
        const idx = ((elapsed/base)%16 + 16)%16;
        const newStep = Math.floor(idx);
        if(newStep !== playStep){
          playStep = newStep;
          renderDrum();
        }
        rafId = requestAnimationFrame(updatePlayhead);
      }

      function startAll(){
        const ok = tracks.some(tr => !!tr.buffer) || sample1Track.buffer || sample2Track.buffer;
        if(!ok){
          setStatus("No sounds (load ./samples or record Sample).");
          return;
        }
        isPlaying=true;
        globalStep=0;
        playStep=0;
        sharedStartTime = ctx.currentTime + 0.02;
        nextTime = sharedStartTime;

        if(timer) clearTimeout(timer);
        if(rafId) cancelAnimationFrame(rafId);

        renderDrum();
        rafId = requestAnimationFrame(updatePlayhead);
        scheduler();

        masterPlayBtn.disabled = true;
        masterStopBtn.disabled = false;
        setStatus("Playing");
      }

      function stopAll(){
        isPlaying=false;
        if(timer) clearTimeout(timer);
        timer=null;
        if(rafId) cancelAnimationFrame(rafId);
        rafId=null;

        hardStopAllSources();
        playStep=0;
        renderDrum();

        masterPlayBtn.disabled = false;
        masterStopBtn.disabled = true;
        setStatus("Stopped");
      }

      masterPlayBtn.addEventListener("click", async ()=>{
        await resumeAudio();
        startAll();
      });

      masterStopBtn.addEventListener("click", ()=>{
        stopAll();
      });

      // ---------- save/load file ----------
      function gatherState(){
        return {
          tempo: tempo(),
          masterVol: +masterVol.value,

          tracks: tracks.map(t=>({ key:t.key, pattern:[...t.pattern] })),

          sampler: {
            s1: { mix:+s1MixEl.value, fb:+s1FbEl.value, pitch:+s1PitchEl.value, has: !!sample1Track.buffer },
            s2: { mix:+s2MixEl.value, fb:+s2FbEl.value, pitch:+s2PitchEl.value, has: !!sample2Track.buffer },
          },

          bass: {
            notes:[...bassState.notes],
            octs:[...bassState.octs],
            cut:+cutEl.value, res:+resEl.value, env:+envEl.value, decay:+bDecayEl.value,
            dMix:+dMixEl.value, dFb:+dFbEl.value
          },

          lead: {
            notes:[...leadState.notes],
            octs:[...leadState.octs],
            cut:+lCutEl.value, res:+lResEl.value, env:+lEnvEl.value, gate:+lGateEl.value,
            dMix:+lMixEl.value, dFb:+lFbEl.value
          },

          mixer: {
            drumVol:+mDrumVolEl.value, bassVol:+mBassVolEl.value, leadVol:+mLeadVolEl.value,
            drumLPF:+mDrumLPFEl.value, bassLPF:+mBassLPFEl.value, leadLPF:+mLeadLPFEl.value,
            mute:{...mute}
          }
        };
      }

      function applyState(s){
        if(!s) return;

        if(s.tempo) tempoEl.value = String(clamp(+s.tempo,80,160));
        tempoVal.textContent = String(tempo());

        if(s.masterVol!=null) masterVol.value = String(clamp(+s.masterVol,0,1));

        if(s.tracks){
          for(const row of s.tracks){
            const tr = tracks.find(t=>t.key===row.key);
            if(tr && Array.isArray(row.pattern) && row.pattern.length===16){
              tr.pattern = row.pattern.map(Boolean);
            }
          }
        }

        if(s.sampler){
          if(s.sampler.s1){
            s1MixEl.value = String(clamp(+s.sampler.s1.mix,0,1));
            s1FbEl.value  = String(clamp(+s.sampler.s1.fb,0,0.75));
            s1PitchEl.value = String(clamp(+s.sampler.s1.pitch,-12,12));
            s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0);
          }
          if(s.sampler.s2){
            s2MixEl.value = String(clamp(+s.sampler.s2.mix,0,1));
            s2FbEl.value  = String(clamp(+s.sampler.s2.fb,0,0.75));
            s2PitchEl.value = String(clamp(+s.sampler.s2.pitch,-12,12));
            s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0);
          }
        }

        if(s.bass){
          bassState.notes = Array.isArray(s.bass.notes) ? s.bass.notes.slice(0,8) : bassState.notes;
          bassState.octs  = Array.isArray(s.bass.octs)  ? s.bass.octs.slice(0,8).map(v=>clamp(+v,-1,1)) : bassState.octs;

          cutEl.value = String(clamp(+s.bass.cut,150,6500));
          resEl.value = String(clamp(+s.bass.res,0,1));
          envEl.value = String(clamp(+s.bass.env,0,1));
          bDecayEl.value = String(clamp(+s.bass.decay,0.05,0.35));
          dMixEl.value = String(clamp(+s.bass.dMix,0,1));
          dFbEl.value  = String(clamp(+s.bass.dFb,0,0.75));
        }

        if(s.lead){
          leadState.notes = Array.isArray(s.lead.notes) ? s.lead.notes.slice(0,8) : leadState.notes;
          leadState.octs  = Array.isArray(s.lead.octs)  ? s.lead.octs.slice(0,8).map(v=>clamp(+v,-1,1)) : leadState.octs;

          lCutEl.value = String(clamp(+s.lead.cut,250,11000));
          lResEl.value = String(clamp(+s.lead.res,0,1));
          lEnvEl.value = String(clamp(+s.lead.env,0,1));
          lGateEl.value = String(clamp(+s.lead.gate,0.10,1));
          lMixEl.value = String(clamp(+s.lead.dMix,0,1));
          lFbEl.value  = String(clamp(+s.lead.dFb,0,0.75));
        }

        if(s.mixer){
          mDrumVolEl.value = String(clamp(+s.mixer.drumVol,0,1));
          mBassVolEl.value = String(clamp(+s.mixer.bassVol,0,1));
          mLeadVolEl.value = String(clamp(+s.mixer.leadVol,0,1));

          mDrumLPFEl.value = String(clamp(+s.mixer.drumLPF,0,1));
          mBassLPFEl.value = String(clamp(+s.mixer.bassLPF,0,1));
          mLeadLPFEl.value = String(clamp(+s.mixer.leadLPF,0,1));

          if(s.mixer.mute){
            mute.drums = !!s.mixer.mute.drums;
            mute.bass  = !!s.mixer.mute.bass;
            mute.lead  = !!s.mixer.mute.lead;
            mDrumMuteBtn.classList.toggle("on", mute.drums);
            mBassMuteBtn.classList.toggle("on", mute.bass);
            mLeadMuteBtn.classList.toggle("on", mute.lead);
            mDrumMuteBtn.textContent = mute.drums ? "Muted" : "Mute";
            mBassMuteBtn.textContent = mute.bass ? "Muted" : "Mute";
            mLeadMuteBtn.textContent = mute.lead ? "Muted" : "Mute";
          }
        }

        // apply now
        if(master) master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);
        if(ctx){
          ensureFX();
          s1FX.update(true); s2FX.update(true);
          bassDelayFX.update(true); leadDelayFX.update(true);
          applyMixerNow(true);
        }

        renderDrum();
        renderSeqGrid(tbGridEl, bassState, "bass");
        renderSeqGrid(leadGridEl, leadState, "lead");
      }

      function downloadJSON(filename, obj){
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type:"application/json" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 50);
      }

      saveFileBtn.addEventListener("click", ()=>{
        downloadJSON("project.mmjson", gatherState());
      });

      loadFileBtn.addEventListener("click", ()=>loadFileInput.click());
      loadFileInput.addEventListener("change", async (e)=>{
        const file = e.target.files && e.target.files[0];
        if(!file) return;
        try{
          const txt = await file.text();
          const obj = safeJSONParse(txt);
          if(obj) applyState(obj);
          setStatus("Loaded ✅");
          scheduleSave();
        }catch(err){
          console.error(err);
          setStatus("Load failed");
        }finally{
          loadFileInput.value = "";
        }
      });

      // live updates for bass/lead delay knobs
      [dMixEl,dFbEl].forEach(el=>bindInput(el, ()=>{ if(ctx){ ensureFX(); bassDelayFX.update(false); } scheduleSave(); }));
      [lMixEl,lFbEl].forEach(el=>bindInput(el, ()=>{ if(ctx){ ensureFX(); leadDelayFX.update(false); } scheduleSave(); }));
      [cutEl,resEl,envEl,bDecayEl,lCutEl,lResEl,lEnvEl,lGateEl].forEach(el=>bindInput(el, scheduleSave));

      // ---------- init ----------
      buildHeader();
      renderDrum();
      renderSeqGrid(tbGridEl, bassState, "bass");
      renderSeqGrid(leadGridEl, leadState, "lead");
      loadAllSounds();

      const saved = loadSaved();
      if(saved){
        applyState(saved);
        setStatus("Autosave loaded ✅");
      }else{
        setStatus("Ready");
      }

      // IMPORTANT: audio starts on interaction already via Play / pad clicks

    })();
  </script>
</body>
</html>
