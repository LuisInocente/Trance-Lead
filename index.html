<!DOCTYPE html>
<html lang="nl">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Drum Machine + Bassline + Trance Lead + Mixer</title>
  <style>
    :root {
      --bg: #ffffff;
      --card: #ffffff;
      --border: #d9d9d9;
      --text: #111;
      --muted: #666;

      --gridBorder: #cfcfcf;
      --cellA: #fff;
      --cellB: #f3f3f3;
      --playhead: rgba(0, 0, 0, .14);

      --t1: hsl(10 85% 72%);
      --t2: hsl(90 70% 72%);
      --t3: hsl(200 80% 72%);
      --t4: hsl(280 75% 76%);
      --t5: hsl(45 90% 72%);
      --t6: hsl(160 70% 72%);
      --t7: hsl(210 85% 78%);
      --t8: hsl(330 75% 78%);

      --noteGrey: #e6e6e6;
      --noteNat: #ffffff;

      --bassOn: #7f1d1d;
      --leadOn: #6d28d9;

      --headerH: 64px;
      --footerH: 40px;
      --gap: 12px;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      overflow: hidden;
    }

    header {
      height: var(--headerH);
      position: sticky;
      top: 0;
      z-index: 50;
      background: #fff;
      border-bottom: 1px solid var(--border);
      padding: 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 10px;
    }

    .topLeft,
    .topRight {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .topLeft {
      justify-content: flex-start
    }

    .topMid {
      display: flex;
      justify-content: center;
      gap: 10px
    }

    .topRight {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      flex-wrap: wrap
    }

    .pill {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }

    .pill strong {
      color: var(--text);
      font-weight: 950
    }

    input[type="range"] {
      accent-color: #111
    }

    .tempoRange {
      width: 220px
    }

    button {
      border: 1px solid var(--border);
      background: #fff;
      height: 40px;
      padding: 0 16px;
      border-radius: 14px;
      cursor: pointer;
      font-weight: 950;
      font-size: 15px;
      white-space: nowrap;
      touch-action: manipulation;
    }

    button.primary {
      background: #111;
      color: #fff;
      border-color: #111
    }

    button:disabled {
      opacity: .55;
      cursor: not-allowed
    }

    .wrap {
      padding: var(--gap);
      height: calc(100vh - var(--headerH) - var(--footerH));
      display: grid;
      grid-template-columns: 1.25fr 1fr 1fr 0.9fr;
      gap: var(--gap);
      align-items: stretch;
      min-height: 0;
    }

    .card {
      border: 1px solid var(--border);
      border-radius: 18px;
      background: #fff;
      box-shadow: 0 10px 28px rgba(0, 0, 0, .06);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .cardHead {
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex: 0 0 auto;
    }

    .title {
      font-size: 16px;
      font-weight: 1000;
      letter-spacing: .2px
    }

    .smallBtn {
      height: 34px;
      padding: 0 12px;
      border-radius: 12px;
      font-size: 13px;
      font-weight: 900
    }

    .body {
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex: 1 1 auto;
      min-height: 0;
    }

    .drumToolsCompact {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: flex-end;
    }

    .drumToolsCompact .smallBtn {
      height: 32px;
      padding: 0 10px;
      font-size: 12px;
      border-radius: 11px;
    }

    .samplerBar {
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fff;
      flex-wrap: wrap;
      flex: 0 0 auto;
    }

    .samplerStatus {
      font-size: 12px;
      font-weight: 950;
      color: var(--muted);
      white-space: nowrap;
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .samplerKnob {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      background: #fff;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
      height: 32px;
    }

    .samplerKnob input[type="range"] {
      width: 78px
    }

    #s1PitchVal,
    #s2PitchVal {
      display: inline-block;
      width: 3ch;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    .gridWrap {
      border: 1px solid var(--gridBorder);
      border-radius: 16px;
      overflow: hidden;
      background: #fff;
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }

    .headerRow {
      display: grid;
      grid-template-columns: 160px repeat(16, 1fr);
      border-bottom: 1px solid var(--gridBorder);
      background: #fff;
      flex: 0 0 auto;
    }

    .headerCell {
      padding: 8px 4px;
      font-size: 10px;
      color: var(--muted);
      text-align: center;
      border-left: 1px solid var(--gridBorder);
      font-weight: 900;
    }

    .headerCell:first-child {
      text-align: left;
      border-left: none;
      padding-left: 10px;
    }

    #grid {
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
    }

    .row {
      display: grid;
      grid-template-columns: 160px repeat(16, 1fr);
    }

    .row+.row {
      border-top: 1px solid var(--gridBorder)
    }

    .trackCell {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 8px 10px;
      border-right: 1px solid var(--gridBorder);
      background: #fff;
    }

    .trackLeft {
      display: flex;
      align-items: center;
      gap: 8px;
      min-width: 0;
      flex: 1 1 auto
    }

    .swatch {
      width: 12px;
      height: 12px;
      border-radius: 999px;
      border: 1px solid rgba(0, 0, 0, .12);
      flex: 0 0 auto
    }

    .trackText {
      display: flex;
      flex-direction: column;
      min-width: 0;
      gap: 1px
    }

    .trackName {
      font-weight: 1000;
      font-size: 12px;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 92px;
      line-height: 1.1;
    }

    .fileLabel {
      font-size: 10px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 92px;
    }

    .mini {
      display: flex;
      gap: 6px;
      align-items: center;
      flex: 0 0 auto
    }

    .mini button {
      height: 30px;
      padding: 0 9px;
      border-radius: 11px;
      font-size: 12px;
      font-weight: 950
    }

    .cell {
      height: 38px;
      border-left: 1px solid var(--gridBorder);
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--cellA);
      cursor: pointer;
      touch-action: manipulation;
    }

    .cell.alt {
      background: var(--cellB)
    }

    .cell.playhead {
      outline: 4px solid var(--playhead);
      outline-offset: -4px
    }

    .cell.on.t1 {
      background: var(--t1)
    }

    .cell.on.t2 {
      background: var(--t2)
    }

    .cell.on.t3 {
      background: var(--t3)
    }

    .cell.on.t4 {
      background: var(--t4)
    }

    .cell.on.t5 {
      background: var(--t5)
    }

    .cell.on.t6 {
      background: var(--t6)
    }

    .cell.on.t7 {
      background: var(--t7)
    }

    .cell.on.t8 {
      background: var(--t8)
    }

    .statusLine {
      font-size: 12px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      flex: 0 0 auto;
    }

    .seqControls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 6px;
      flex: 0 0 auto;
    }

    .seqControls .pill input[type="range"] {
      width: 120px
    }

    .tb_grid {
      display: grid;
      grid-template-columns: 58px repeat(8, 1fr);
      column-gap: 8px;
      align-items: stretch;
      flex: 1 1 auto;
      min-height: 0;
    }

    .tb_labels,
    .tb_col {
      display: grid;
      grid-template-rows: 18px 50px 10px repeat(12, minmax(18px, 1fr));
      gap: 6px;
      height: 100%;
      min-height: 0;
    }

    .tb_labels {
      font-size: 12px;
      color: var(--muted);
      user-select: none
    }

    .tb_labels .muted {
      font-size: 11px;
      font-weight: 950;
      letter-spacing: .2px
    }

    .tb_stepNum {
      text-align: center;
      font-size: 12px;
      font-weight: 1000;
      user-select: none
    }

    .tb_oct {
      display: grid;
      grid-template-rows: repeat(3, 1fr);
      gap: 6px;
      height: 50px;
      margin-bottom: 0;
    }

    .tb_octBtn {
      width: 100%;
      height: 100%;
      border: 1px solid var(--border);
      background: #fff;
      cursor: pointer;
      border-radius: 8px;
      touch-action: manipulation;
      font-weight: 1000;
      font-size: 12px;
      line-height: 1;
    }

    .tb_spacer {
      height: 10px;
    }

    .tb_pad {
      width: 100%;
      height: 100%;
      border: 1px solid var(--border);
      background: var(--noteGrey);
      cursor: pointer;
      border-radius: 10px;
      touch-action: manipulation;
    }

    .tb_pad.nat {
      background: var(--noteNat)
    }

    .bass .tb_pad.on {
      background: var(--bassOn) !important;
      border-color: var(--bassOn) !important;
    }

    .bass .tb_octBtn.on {
      background: var(--bassOn) !important;
      border-color: var(--bassOn) !important;
      color: #fff;
    }

    .lead .tb_pad.on {
      background: var(--leadOn) !important;
      border-color: var(--leadOn) !important;
    }

    .lead .tb_octBtn.on {
      background: var(--leadOn) !important;
      border-color: var(--leadOn) !important;
      color: #fff;
    }

    .mixerGrid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      align-items: stretch;
      flex: 1 1 auto;
      min-height: 0;
    }

    .chan {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 10px 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      background: #fff;
    }

    .chanTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex: 0 0 auto;
    }

    .chanName {
      font-weight: 1000;
      font-size: 13px;
      color: var(--text)
    }

    .muteBtn {
      height: 30px;
      padding: 0 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 1000;
    }

    .muteBtn.on {
      background: #111;
      color: #fff;
      border-color: #111
    }

    .faderWrap {
      display: flex;
      gap: 10px;
      align-items: flex-end;
      justify-content: space-between;
      flex: 1 1 auto;
      min-height: 0;
    }

    .faderCol {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      flex: 1 1 0;
      min-height: 0;
    }

    .faderLabel {
      font-size: 11px;
      color: var(--muted);
      font-weight: 950
    }

    .vfaderShell {
      position: relative;
      width: 34px;
      height: 220px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .vfader {
      -webkit-appearance: none;
      appearance: none;
      width: 220px;
      height: 34px;
      background: transparent;
      transform: rotate(-90deg);
      display: block;
      margin: 0;
      padding: 0;
    }

    .vfader:focus {
      outline: none
    }

    .vfader::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .08);
      border: 1px solid rgba(0, 0, 0, .10);
    }

    .vfader::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: #111;
      border: 2px solid #111;
      margin-top: -9px;
      cursor: pointer;
    }

    .vfader::-moz-range-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .08);
      border: 1px solid rgba(0, 0, 0, .10);
    }

    .vfader::-moz-range-thumb {
      width: 26px;
      height: 26px;
      border-radius: 999px;
      background: #111;
      border: 2px solid #111;
      cursor: pointer;
    }

    /* Recording countdown */
    .recBox {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 14px;
      background: #fff;
      min-width: 140px;
    }

    .recTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px
    }

    .recTop .lbl {
      font-size: 12px;
      color: var(--muted);
      font-weight: 950
    }

    .recTop .val {
      font-size: 12px;
      color: var(--text);
      font-weight: 1000;
      font-variant-numeric: tabular-nums
    }

    .recBar {
      height: 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .08);
      border: 1px solid rgba(0, 0, 0, .10);
      overflow: hidden;
    }

    .recFill {
      height: 100%;
      width: 0%;
      background: #111
    }

    footer {
      height: var(--footerH);
      border-top: 1px solid var(--border);
      display: grid;
      grid-template-columns: 1.25fr 1fr 1fr 0.9fr;
      gap: var(--gap);
      padding: 10px 12px;
      align-items: center;
      color: var(--muted);
      font-size: 12px;
    }

    .footerSpacer {
      grid-column: 1 / span 3;
    }

    .footerRight {
      grid-column: 4;
      justify-self: start;
      font-weight: 900;
      color: var(--muted);
    }

    @media (max-width:1200px) {
      body {
        overflow: auto
      }

      .wrap {
        height: auto;
        grid-template-columns: 1fr;
      }

      footer {
        grid-template-columns: 1fr;
        height: auto;
      }

      .footerSpacer {
        display: none
      }

      .footerRight {
        grid-column: 1;
        justify-self: end
      }
    }
  </style>
</head>

<body>
  <header>
    <div class="topLeft">
      <div class="pill">
        <span>Tempo</span>
        <input id="tempo" class="tempoRange" type="range" min="80" max="160" value="120">
        <strong id="tempoVal">120</strong>
      </div>
    </div>

    <div class="topMid">
      <button id="masterPlay" class="primary">Play</button>
      <button id="masterStop" disabled>Stop</button>
    </div>

    <div class="topRight">
      <div class="pill">
        <span>Vol</span>
        <input id="masterVol" type="range" min="0" max="1" value="0.9" step="0.01">
      </div>

      <div class="recBox" title="Countdown van 60 → 0 tijdens opnemen">
        <div class="recTop">
          <div class="lbl">REC</div>
          <div class="val"><span id="recCountdown">60</span>s</div>
        </div>
        <div class="recBar">
          <div id="recFill" class="recFill"></div>
        </div>
      </div>

      <button id="recBtn" class="smallBtn">Record 1:00</button>
      <button id="recStopBtn" class="smallBtn" disabled>Stop Rec</button>
      <button id="recExportBtn" class="smallBtn" disabled>Export WAV</button>
    </div>
  </header>

  <div class="wrap">
    <!-- DRUM MACHINE -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Drum Machine</div>
        <div class="drumToolsCompact">
          <button id="saveFileBtn" class="smallBtn">Save</button>
          <button id="loadFileBtn" class="smallBtn">Load</button>
          <input id="loadFileInput" type="file" accept=".mmjson,application/json" style="display:none" />
          <button id="clear" class="smallBtn">Clear</button>
        </div>
      </div>

      <div class="body">
        <div class="samplerBar">
          <strong style="font-size:12px">Sample 1</strong>
          <button id="s1RecBtn" class="smallBtn">2s</button>
          <button id="s1PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s1ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s1Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s1Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s1Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s1PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s1Status" class="samplerStatus">No sample</span>
        </div>

        <div class="samplerBar">
          <strong style="font-size:12px">Sample 2</strong>
          <button id="s2RecBtn" class="smallBtn">2s</button>
          <button id="s2PlayBtn" class="smallBtn" disabled>▶</button>
          <button id="s2ClearBtn" class="smallBtn" disabled>✕</button>

          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Mix</span>
            <input id="s2Mix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">FB</span>
            <input id="s2Fb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
          <div class="samplerKnob">
            <span style="font-weight:950;color:var(--text)">Pitch</span>
            <input id="s2Pitch" type="range" min="-12" max="12" step="1" value="0">
            <strong id="s2PitchVal" style="color:var(--text);font-weight:950">+00</strong>
          </div>

          <span id="s2Status" class="samplerStatus">No sample</span>
        </div>

        <div class="gridWrap">
          <div class="headerRow" id="headerRow"></div>
          <div id="grid"></div>
        </div>

        <div class="statusLine">
          <div id="statusLeft"></div>
          <div id="statusRight"></div>
        </div>
      </div>
    </div>

    <!-- BASSLINE -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Bassline</div>
        <div></div>
      </div>

      <div class="body bass">
        <div class="seqControls">
          <button id="bassReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="cutoff" type="range" min="0" max="1" step="0.001" value="0.32">
          </div>
          <div class="pill"><span>Res</span><input id="reso" type="range" min="0" max="1" step="0.01" value="0.30">
          </div>
          <div class="pill"><span>Env</span><input id="env" type="range" min="0" max="1" step="0.01" value="0.45"></div>
          <div class="pill"><span>Decay</span><input id="bDecay" type="range" min="0.05" max="0.45" step="0.01" value="0.18">
          </div>
          <div class="pill"><span>Mix</span><input id="dMix" type="range" min="0" max="1" step="0.01" value="0.18">
          </div>
          <div class="pill"><span>FB</span><input id="dFb" type="range" min="0" max="0.75" step="0.01" value="0.22">
          </div>
        </div>

        <div id="tb_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- TRANCE LEAD -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Trance Lead (2×)</div>
        <div></div>
      </div>

      <div class="body lead">
        <div class="seqControls">
          <button id="leadReset" class="smallBtn">Reset</button>

          <div class="pill"><span>Cut</span><input id="lCutoff" type="range" min="0" max="1" step="0.001" value="0.46">
          </div>
          <div class="pill"><span>Res</span><input id="lReso" type="range" min="0" max="1" step="0.01" value="0.22">
          </div>
          <div class="pill"><span>Env</span><input id="lEnv" type="range" min="0" max="1" step="0.01" value="0.62">
          </div>
          <div class="pill"><span>Gate</span><input id="lGate" type="range" min="0.10" max="1" step="0.01" value="0.55">
          </div>
          <div class="pill"><span>Mix</span><input id="lMix" type="range" min="0" max="1" step="0.01" value="0.16">
          </div>
          <div class="pill"><span>FB</span><input id="lFb" type="range" min="0" max="0.75" step="0.01" value="0.18">
          </div>
        </div>

        <div id="lead_grid" class="tb_grid"></div>
      </div>
    </div>

    <!-- MIXER -->
    <div class="card">
      <div class="cardHead">
        <div class="title">Mixer</div>
        <div></div>
      </div>

      <div class="body">
        <div class="mixerGrid">
          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Drums</div>
              <button id="mDrumMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mDrumVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.20">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mDrumLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="1.00">
                </div>
              </div>
            </div>
          </div>

          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Bass</div>
              <button id="mBassMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mBassVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.20">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mBassLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="1.00">
                </div>
              </div>
            </div>
          </div>

          <div class="chan">
            <div class="chanTop">
              <div class="chanName">Lead</div>
              <button id="mLeadMute" class="muteBtn">Mute</button>
            </div>
            <div class="faderWrap">
              <div class="faderCol">
                <div class="faderLabel">Vol</div>
                <div class="vfaderShell">
                  <input id="mLeadVol" class="vfader" type="range" min="0" max="1" step="0.01" value="0.32">
                </div>
              </div>
              <div class="faderCol">
                <div class="faderLabel">LPF</div>
                <div class="vfaderShell">
                  <input id="mLeadLPF" class="vfader" type="range" min="0" max="1" step="0.01" value="1.00">
                </div>
              </div>
            </div>
          </div>
        </div>

        
      </div>
    </div>
  </div>

  <footer>
    <div class="footerSpacer"></div>
    <div class="footerRight">Muziek met meester Luis 2026</div>
  </footer>

  <script>
    (() => {
    "use strict";

    // -----------------
    // Helpers
    // -----------------
    function safeJSONParse(s){ try{ return JSON.parse(s); }catch(_){ return null; } }
    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }

    const tempoEl = document.getElementById("tempo");
    const tempoVal = document.getElementById("tempoVal");
    const masterVol = document.getElementById("masterVol");
    const masterPlayBtn = document.getElementById("masterPlay");
    const masterStopBtn = document.getElementById("masterStop");

    const statusLeft  = document.getElementById("statusLeft");
    const statusRight = document.getElementById("statusRight");
    function setStatus(t){ statusLeft.textContent = t || ""; }

    function tempo(){ return clamp(parseFloat(tempoEl.value||120), 80, 160); }
    function quarterSec(){ return 60/tempo(); }
    function eighthSec(){ return quarterSec()/2; }
    function sixteenthSec(){ return quarterSec()/4; }
    function dotted8Sec(){ return quarterSec() * 0.75; }

    tempoVal.textContent = String(tempo());

    function bindInput(el, fn){
      el.addEventListener("input", fn, { passive:true });
      el.addEventListener("change", fn, { passive:true });
    }

    function expMap01(x, minHz, maxHz){
      x = clamp(x, 0, 1);
      const a = Math.log(minHz);
      const b = Math.log(maxHz);
      return Math.exp(a + (b-a)*x);
    }

    // -----------------
    // Audio init + buses
    // -----------------
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let ctx = null;

    let master = null;
    let drumBus = null, bassBus = null, leadBus = null;
    let drumGain=null, bassGain=null, leadGain=null;
    let drumLPF=null, bassLPF=null, leadLPF=null;

    // recorder
    let recDest = null;
    let mediaRec = null;
    let recChunks = [];
    let recBlob = null;
    let recTimeout = null;

    function ensureAudio(){
      if(ctx) return;
      ctx = new AudioCtx();

      master = ctx.createGain();
      master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);

      drumBus = ctx.createGain();
      bassBus = ctx.createGain();
      leadBus = ctx.createGain();

      drumLPF = ctx.createBiquadFilter(); drumLPF.type="lowpass";
      bassLPF = ctx.createBiquadFilter(); bassLPF.type="lowpass";
      leadLPF = ctx.createBiquadFilter(); leadLPF.type="lowpass";

      drumGain = ctx.createGain();
      bassGain = ctx.createGain();
      leadGain = ctx.createGain();

      drumBus.connect(drumLPF); drumLPF.connect(drumGain); drumGain.connect(master);
      bassBus.connect(bassLPF); bassLPF.connect(bassGain); bassGain.connect(master);
      leadBus.connect(leadLPF); leadLPF.connect(leadGain); leadGain.connect(master);

      const hp = ctx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 25;

      recDest = ctx.createMediaStreamDestination();
      master.connect(recDest);

      master.connect(hp);
      hp.connect(ctx.destination);

      applyMixerNow(true);
    }

    async function resumeAudio(){
      ensureAudio();
      try{ await ctx.resume(); }catch(_){}
    }

    bindInput(masterVol, ()=>{
      if(master) master.gain.value = clamp(parseFloat(masterVol.value||0.9),0,1);
      scheduleSave();
    });

    bindInput(tempoEl, ()=>{
      tempoVal.textContent = String(tempo());
      if(ctx){
        if(s1FX) s1FX.update(false);
        if(s2FX) s2FX.update(false);
        if(bassDelayFX) bassDelayFX.update(false);
        if(leadDelayFX) leadDelayFX.update(false);
      }
      scheduleSave();
    });

    // -----------------
    // Autosave
    // -----------------
    const STORE_KEY = "mm_drum_bass_lead_mixer_v4";
    let saveTimer = null;
    let dirty = false;

    function markDirty(){ dirty = true; }
    function scheduleSave(){
      markDirty();
      clearTimeout(saveTimer);
      saveTimer = setTimeout(saveNow, 200);
    }
    function saveNow(){
      try{
        localStorage.setItem(STORE_KEY, JSON.stringify(gatherState()));
        dirty = false;
      }catch(_){}
    }
    function loadSaved(){
      const raw = localStorage.getItem(STORE_KEY);
      return raw ? safeJSONParse(raw) : null;
    }
    window.addEventListener("beforeunload", ()=>{ if(dirty) saveNow(); });
    setInterval(()=>{ if(dirty) saveNow(); }, 2000);

    // -----------------
    // Mixer (LPF: bottom=dicht, top=open)
    // -----------------
    const mDrumVolEl = document.getElementById("mDrumVol");
    const mBassVolEl = document.getElementById("mBassVol");
    const mLeadVolEl = document.getElementById("mLeadVol");

    const mDrumLPFEl = document.getElementById("mDrumLPF");
    const mBassLPFEl = document.getElementById("mBassLPF");
    const mLeadLPFEl = document.getElementById("mLeadLPF");

    const mDrumMuteBtn = document.getElementById("mDrumMute");
    const mBassMuteBtn = document.getElementById("mBassMute");
    const mLeadMuteBtn = document.getElementById("mLeadMute");

    const mute = { drums:false, bass:false, lead:false };

    function volFromFader(v){
      v = clamp(+v||0, 0, 1);
      return v; // top=1, bottom=0
    }
    function cutoffFromLPFFader(v){
      v = clamp(+v||0, 0, 1);
      return expMap01(v, 30, 20000);
    }

    function applyMixerNow(instant=false){
      if(!ctx) return;
      const t = ctx.currentTime;
      const tau = instant ? 0.001 : 0.02;

      const drumVol = mute.drums ? 0 : volFromFader(mDrumVolEl.value);
      const bassVol = mute.bass ? 0 : volFromFader(mBassVolEl.value);
      const leadVol = mute.lead ? 0 : volFromFader(mLeadVolEl.value);

      const drumCut = cutoffFromLPFFader(mDrumLPFEl.value);
      const bassCut = cutoffFromLPFFader(mBassLPFEl.value);
      const leadCut = cutoffFromLPFFader(mLeadLPFEl.value);

      drumGain.gain.setTargetAtTime(drumVol, t, tau);
      bassGain.gain.setTargetAtTime(bassVol, t, tau);
      leadGain.gain.setTargetAtTime(leadVol, t, tau);

      drumLPF.frequency.setTargetAtTime(drumCut, t, tau);
      bassLPF.frequency.setTargetAtTime(bassCut, t, tau);
      leadLPF.frequency.setTargetAtTime(leadCut, t, tau);

      drumLPF.Q.setTargetAtTime(0.6, t, tau);
      bassLPF.Q.setTargetAtTime(0.7, t, tau);
      leadLPF.Q.setTargetAtTime(0.6, t, tau);
    }

    function hookMixer(){
      const mixerUpdate = ()=>{
        if(ctx) applyMixerNow(false);
        scheduleSave();
      };

      [mDrumVolEl,mBassVolEl,mLeadVolEl,mDrumLPFEl,mBassLPFEl,mLeadLPFEl].forEach(el=>{
        bindInput(el, mixerUpdate);
      });

      function toggleMute(which, btn){
        mute[which] = !mute[which];
        btn.classList.toggle("on", mute[which]);
        btn.textContent = mute[which] ? "Muted" : "Mute";
        if(ctx) applyMixerNow(false);
        scheduleSave();
      }
      mDrumMuteBtn.addEventListener("click", ()=>toggleMute("drums", mDrumMuteBtn));
      mBassMuteBtn.addEventListener("click", ()=>toggleMute("bass", mBassMuteBtn));
      mLeadMuteBtn.addEventListener("click", ()=>toggleMute("lead", mLeadMuteBtn));
    }

    // -----------------
    // Delay FX helper
    // -----------------
    function makeDelayFX({ mixEl, fbEl }, destBus, timeMode="dotted8"){
      const dry = ctx.createGain();
      const wetIn = ctx.createGain();
      const delay = ctx.createDelay(2.0);
      const fb = ctx.createGain();
      const wetOut = ctx.createGain();

      // NOTE: NO feedback to destBus. Only wetOut->destBus.
      wetIn.connect(delay);
      delay.connect(wetOut);
      wetOut.connect(destBus);

      delay.connect(fb);
      fb.connect(delay);

      dry.connect(destBus);

      function update(instant=false){
        const t = ctx.currentTime;
        const dt = (timeMode==="dotted8") ? dotted8Sec() : quarterSec();
        const mix = clamp(parseFloat(mixEl.value||0), 0, 1);
        const fbb = clamp(parseFloat(fbEl.value||0), 0, 0.75);

        const tau = instant ? 0.001 : 0.02;
        delay.delayTime.setTargetAtTime(dt, t, tau);
        fb.gain.setTargetAtTime(fbb, t, tau);

        dry.gain.setTargetAtTime(1 - mix, t, tau);
        wetIn.gain.setTargetAtTime(mix, t, tau);
      }

      update(true);
      return { dry, wetIn, update };
    }

    // -----------------
    // DRUM MACHINE (unchanged)
    // -----------------
    const headerRow = document.getElementById("headerRow");
    const gridEl    = document.getElementById("grid");
    const clearBtn  = document.getElementById("clear");

    const s1RecBtn   = document.getElementById("s1RecBtn");
    const s1PlayBtn  = document.getElementById("s1PlayBtn");
    const s1ClearBtn = document.getElementById("s1ClearBtn");
    const s1Status   = document.getElementById("s1Status");
    const s1MixEl    = document.getElementById("s1Mix");
    const s1FbEl     = document.getElementById("s1Fb");
    const s1PitchEl  = document.getElementById("s1Pitch");
    const s1PitchVal = document.getElementById("s1PitchVal");

    const s2RecBtn   = document.getElementById("s2RecBtn");
    const s2PlayBtn  = document.getElementById("s2PlayBtn");
    const s2ClearBtn = document.getElementById("s2ClearBtn");
    const s2Status   = document.getElementById("s2Status");
    const s2MixEl    = document.getElementById("s2Mix");
    const s2FbEl     = document.getElementById("s2Fb");
    const s2PitchEl  = document.getElementById("s2Pitch");
    const s2PitchVal = document.getElementById("s2PitchVal");

    function sampleRateFromSemis(semis){ return Math.pow(2, (semis/12)); }
    function fmtPitch(v){
      v = Math.max(-12, Math.min(12, (v|0)));
      const sign = (v >= 0) ? "+" : "-";
      const n = String(Math.abs(v)).padStart(2,"0");
      return sign + n;
    }

    const STEPS = 16;
    const activeSources = new Set();

    const TRACKS_DEF = [
      { name:"Kick",     key:"kick",     colorClass:"t1" },
      { name:"Snare",    key:"snare",    colorClass:"t2" },
      { name:"Hat",      key:"hat",      colorClass:"t3" },
      { name:"OpenHat",  key:"openhat",  colorClass:"t7" },
      { name:"Clap",     key:"clap",     colorClass:"t4" },
      { name:"Perc",     key:"perc",     colorClass:"t5" },
      { name:"Sample 1", key:"sample1",  colorClass:"t6", isSampler:true, samplerId:1 },
      { name:"Sample 2", key:"sample2",  colorClass:"t8", isSampler:true, samplerId:2 },
    ];

    let tracks = TRACKS_DEF.map(t => ({
      ...t,
      fileLabel: t.isSampler ? "No sample" : "Loading…",
      buffer: null,
      pattern: Array(STEPS).fill(false),
    }));

    const sample1Track = tracks.find(t => t.key === "sample1");
    const sample2Track = tracks.find(t => t.key === "sample2");

    let s1FX = null, s2FX = null;

    function playBufferAt(buf, time, destination){
      if(!ctx || !destination || !buf) return;
      const src = ctx.createBufferSource();
      src.buffer = buf;
      src.connect(destination);

      activeSources.add(src);
      src.onended = () => activeSources.delete(src);

      try{ src.start(time); }catch(_){}
      return src;
    }

    function hardStopAllSources(){
      for(const src of Array.from(activeSources)){
        try{ src.stop(0); }catch(_){}
        activeSources.delete(src);
      }
    }

    function applyTinyFade(buf, fadeMs = 2){
      if(!buf || !ctx) return buf;
      const sr = buf.sampleRate;
      const n = Math.max(1, Math.floor(sr * (fadeMs/1000)));
      for(let c=0;c<buf.numberOfChannels;c++){
        const d = buf.getChannelData(c);
        const L = d.length;
        const nn = Math.min(n, Math.floor(L/2));
        for(let i=0;i<nn;i++){
          const g = (nn<=1) ? 1 : (i/(nn-1));
          d[i] *= g;
          d[L-1-i] *= g;
        }
      }
      return buf;
    }

    function trimBufferPrecise(buf, {
      thr = 0.018,
      minRunMs = 2.0,
      prerollMs = 6.0,
      tailThr = 0.012,
      tailHoldMs = 25.0
    } = {}){
      const sr = buf.sampleRate;
      const len = buf.length;
      const ch0 = buf.getChannelData(0);

      const minRun = Math.max(1, Math.floor(sr * (minRunMs/1000)));
      const preroll = Math.floor(sr * (prerollMs/1000));
      const tailHold = Math.max(1, Math.floor(sr * (tailHoldMs/1000)));

      let start = 0, run = 0, found = false;
      for(let i=0;i<len;i++){
        const a = Math.abs(ch0[i]);
        if(a >= thr){
          run++;
          if(run >= minRun){
            start = Math.max(0, i - run + 1 - preroll);
            found = true;
            break;
          }
        }else run = 0;
      }
      if(!found) return buf;

      let end = len;
      let quietRun = 0;
      for(let i=len-1;i>=0;i--){
        const a = Math.abs(ch0[i]);
        if(a < tailThr){
          quietRun++;
          if(quietRun >= tailHold){
            end = Math.min(len, i + quietRun);
            break;
          }
        }else quietRun = 0;
      }

      const minKeep = Math.floor(sr * 0.06);
      if(end - start < minKeep) end = Math.min(len, start + minKeep);

      start = Math.max(0, Math.min(start, len-1));
      end = Math.max(start+1, Math.min(end, len));

      const outLen = end - start;
      const out = ctx.createBuffer(buf.numberOfChannels, outLen, sr);
      for(let c=0;c<buf.numberOfChannels;c++){
        const src = buf.getChannelData(c);
        const dst = out.getChannelData(c);
        dst.set(src.subarray(start, end));
      }
      return out;
    }

    function ensureSampleFX(){
      if(s1FX && s2FX) return;
      s1FX = makeDelayFX({ mixEl:s1MixEl, fbEl:s1FbEl }, drumBus, "quarter");
      s2FX = makeDelayFX({ mixEl:s2MixEl, fbEl:s2FbEl }, drumBus, "quarter");
    }

    function setSamplerUI(which, has){
      const is1 = which === 1;
      const playBtn = is1 ? s1PlayBtn : s2PlayBtn;
      const clrBtn  = is1 ? s1ClearBtn : s2ClearBtn;
      const status  = is1 ? s1Status : s2Status;
      const tr      = is1 ? sample1Track : sample2Track;

      playBtn.disabled = !has;
      clrBtn.disabled  = !has;

      if(!has){
        status.textContent = "No sample";
        tr.fileLabel = "No sample";
      }else{
        status.textContent = "Sample ready ✅";
        tr.fileLabel = "Recorded";
      }
    }
    setSamplerUI(1,false);
    setSamplerUI(2,false);

    let _rec=null, _chunks=[], _stream=null, _recWhich=1;

    async function recordSample2s(which){
      await resumeAudio();
      ensureSampleFX();

      if(!navigator.mediaDevices?.getUserMedia){
        alert("Microfoon werkt niet in deze browser.");
        return;
      }
      if(_rec && _rec.state === "recording") return;

      _recWhich = which;
      (which===1 ? s1Status : s2Status).textContent = "Recording…";
      (which===1 ? s1PlayBtn : s2PlayBtn).disabled = true;
      (which===1 ? s1ClearBtn : s2ClearBtn).disabled = true;

      try{
        _stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true }
        });

        _chunks = [];
        _rec = new MediaRecorder(_stream);

        _rec.ondataavailable = (e)=>{
          if(e.data && e.data.size) _chunks.push(e.data);
        };

        _rec.onstop = async ()=>{
          const tr = (_recWhich===1) ? sample1Track : sample2Track;
          try{
            const blob = new Blob(_chunks, { type: _rec.mimeType || "audio/webm" });
            const arr = await blob.arrayBuffer();
            const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
            const trimmed = trimBufferPrecise(buf, {});
            tr.buffer = applyTinyFade(trimmed, 2);
            setSamplerUI(_recWhich, true);
            renderDrum();
            scheduleSave();
          }catch(err){
            console.error(err);
            tr.buffer = null;
            setSamplerUI(_recWhich, false);
            (tr===sample1Track ? s1Status : s2Status).textContent = "Sample failed";
            renderDrum();
          }finally{
            if(_stream) _stream.getTracks().forEach(t=>t.stop());
            _stream = null;
          }
        };

        _rec.start();
        setTimeout(()=>{
          if(_rec && _rec.state === "recording"){
            try{ _rec.stop(); }catch(_){}
          }
        }, 2000);

      }catch(err){
        console.error(err);
        (which===1 ? s1Status : s2Status).textContent = "Mic blocked";
        setSamplerUI(which, false);
      }
    }

    function playSampleNow(which, time){
      const tr = (which===1) ? sample1Track : sample2Track;
      if(!tr.buffer || !ctx) return;

      ensureSampleFX();
      const fx = (which===1) ? s1FX : s2FX;
      fx.update(false);

      const t = (typeof time === "number") ? time : ctx.currentTime;
      const src = ctx.createBufferSource();
      src.buffer = tr.buffer;

      const semis = (which===1 ? (+s1PitchEl.value||0) : (+s2PitchEl.value||0));
      src.playbackRate.setValueAtTime(sampleRateFromSemis(semis), t);

      src.connect(fx.dry);
      src.connect(fx.wetIn);

      activeSources.add(src);
      src.onended = () => activeSources.delete(src);

      try{ src.start(t); }catch(_){}
    }

    function clearSample(which){
      const tr = (which===1) ? sample1Track : sample2Track;
      tr.buffer = null;
      setSamplerUI(which, false);
      renderDrum();
      scheduleSave();
    }

    bindInput(s1PitchEl, ()=>{ s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0); scheduleSave(); });
    bindInput(s2PitchEl, ()=>{ s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0); scheduleSave(); });
    s1PitchVal.textContent = fmtPitch(+s1PitchEl.value||0);
    s2PitchVal.textContent = fmtPitch(+s2PitchEl.value||0);

    function hookSamplerKnobs(which){
      const mixEl = which===1 ? s1MixEl : s2MixEl;
      const fbEl  = which===1 ? s1FbEl  : s2FbEl;
      bindInput(mixEl, ()=>{ if(ctx){ ensureSampleFX(); (which===1?s1FX:s2FX).update(false); } scheduleSave(); });
      bindInput(fbEl,  ()=>{ if(ctx){ ensureSampleFX(); (which===1?s1FX:s2FX).update(false); } scheduleSave(); });
    }
    hookSamplerKnobs(1);
    hookSamplerKnobs(2);

    s1RecBtn.addEventListener("click", ()=>recordSample2s(1));
    s2RecBtn.addEventListener("click", ()=>recordSample2s(2));
    s1PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(1, ctx.currentTime); });
    s2PlayBtn.addEventListener("click", async ()=>{ await resumeAudio(); playSampleNow(2, ctx.currentTime); });
    s1ClearBtn.addEventListener("click", ()=>clearSample(1));
    s2ClearBtn.addEventListener("click", ()=>clearSample(2));

    async function fetchArrayBuffer(url){
      const r = await fetch(url, { cache:"no-store" });
      if(!r.ok) throw new Error("HTTP " + r.status);
      return await r.arrayBuffer();
    }

    async function loadOneTrack(tr){
      tr.buffer = null;
      tr.fileLabel = "Missing file";
      for(const ext of ["wav","mp3","ogg"]){
        const url = "./samples/" + tr.key + "." + ext;
        try{
          const arr = await fetchArrayBuffer(url);
          const buf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));
          tr.buffer = buf;
          tr.fileLabel = tr.key + "." + ext;
          return true;
        }catch(_){}
      }
      return false;
    }

    async function loadAllSounds(){
      await resumeAudio();
      setStatus("Loading sounds…");
      renderDrum();

      let ok = 0;
      for(const tr of tracks){
        if(tr.isSampler){
          tr.fileLabel = tr.buffer ? "Recorded" : "No sample";
          continue;
        }
        if(await loadOneTrack(tr)) ok++;
        renderDrum();
      }
      setStatus(ok ? `Ready (${ok}/${tracks.filter(t=>!t.isSampler).length}).` : "No sounds loaded (check ./samples filenames).");
      renderDrum();
    }

    let drumIsRunning=false, drumStep=0, drumNextTime=0, drumTimer=null;
    let playStep=0, rafId=null;

    function scheduleDrumStep(stepIndex,time){
      for(const tr of tracks){
        if(tr.pattern[stepIndex]){
          if(tr.isSampler){
            if(tr.key === "sample1") playSampleNow(1, time);
            else if(tr.key === "sample2") playSampleNow(2, time);
          }else if(tr.buffer){
            playBufferAt(tr.buffer, time, drumBus);
          }
        }
      }
    }

    const AHEAD_SEC = 0.04;
    const LOOKAHEAD_MS = 15;

    function drumScheduler(){
      if(!drumIsRunning) return;
      const base = sixteenthSec();
      while(drumNextTime < ctx.currentTime + AHEAD_SEC){
        scheduleDrumStep(drumStep, drumNextTime);
        drumStep = (drumStep + 1) % 16;
        drumNextTime += base;
      }
      drumTimer = setTimeout(drumScheduler, LOOKAHEAD_MS);
    }

    let sharedStartTime = 0;

    function updatePlayhead(){
      if(!drumIsRunning) return;
      const base = sixteenthSec();
      const elapsed = ctx.currentTime - sharedStartTime;
      const idx = ((elapsed/base)%16 + 16)%16;
      const newStep = Math.floor(idx);
      if(newStep !== playStep){
        playStep = newStep;
        renderDrum();
      }
      rafId = requestAnimationFrame(updatePlayhead);
    }

    function drumStart(t0){
      const ok = tracks.some(tr => !!tr.buffer);
      if(!ok){
        setStatus("No sounds (load ./samples or record Sample).");
        return false;
      }
      drumIsRunning=true;
      drumStep=0;
      playStep=0;
      drumNextTime=t0;

      if(drumTimer) clearTimeout(drumTimer);
      if(rafId) cancelAnimationFrame(rafId);

      renderDrum();
      rafId = requestAnimationFrame(updatePlayhead);
      drumScheduler();
      return true;
    }

    function drumStop(){
      drumIsRunning=false;
      if(drumTimer) clearTimeout(drumTimer);
      drumTimer=null;
      if(rafId) cancelAnimationFrame(rafId);
      rafId=null;
      hardStopAllSources();
      playStep=0;
      renderDrum();
    }

    function buildHeader(){
      headerRow.innerHTML = "";
      const left = document.createElement("div");
      left.className = "headerCell";
      left.textContent = "Sounds";
      headerRow.appendChild(left);

      for(let s=0;s<16;s++){
        const d=document.createElement("div");
        d.className="headerCell";
        d.textContent = (s%4===0) ? String((s/4)+1) : "";
        headerRow.appendChild(d);
      }
    }

    function renderDrum(){
      gridEl.innerHTML = "";
      tracks.forEach(tr=>{
        const row=document.createElement("div");
        row.className="row";

        const trackCell=document.createElement("div");
        trackCell.className="trackCell";

        const left=document.createElement("div");
        left.className="trackLeft";

        const sw=document.createElement("div");
        sw.className="swatch";
        sw.style.background = (getComputedStyle(document.documentElement).getPropertyValue(`--${tr.colorClass}`).trim() || "#ccc");
        left.appendChild(sw);

        const text=document.createElement("div");
        text.className="trackText";

        const name=document.createElement("div");
        name.className="trackName";
        name.textContent = tr.name + (tr.isSampler ? "" : (tr.buffer ? "" : " ⚠"));

        const file=document.createElement("div");
        file.className="fileLabel";
        file.textContent = tr.fileLabel;

        text.appendChild(name);
        text.appendChild(file);
        left.appendChild(text);

        trackCell.appendChild(left);

        const mini=document.createElement("div");
        mini.className="mini";
        const prev=document.createElement("button");
        prev.textContent="▶";
        prev.className="smallBtn";
        prev.disabled = !tr.buffer;
        prev.addEventListener("click", async ()=>{
          await resumeAudio();
          if(tr.isSampler){
            if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
            if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
          }else{
            playBufferAt(tr.buffer, ctx.currentTime, drumBus);
          }
        });
        mini.appendChild(prev);
        trackCell.appendChild(mini);

        row.appendChild(trackCell);

        for(let s=0;s<16;s++){
          const cell=document.createElement("div");
          cell.className = "cell" + ((((s+1)%2)?" alt":""));
          if(tr.pattern[s]) cell.classList.add("on", tr.colorClass);
          if(drumIsRunning && s===playStep) cell.classList.add("playhead");

          cell.addEventListener("click", async ()=>{
            tr.pattern[s] = !tr.pattern[s];
            await resumeAudio();

            if(tr.pattern[s]){
              if(tr.isSampler){
                if(tr.key==="sample1") playSampleNow(1, ctx.currentTime);
                if(tr.key==="sample2") playSampleNow(2, ctx.currentTime);
              }else if(tr.buffer){
                playBufferAt(tr.buffer, ctx.currentTime, drumBus);
              }
            }
            renderDrum();
            scheduleSave();
          });

          row.appendChild(cell);
        }

        gridEl.appendChild(row);
      });
    }

    clearBtn.addEventListener("click", ()=>{
      for(const tr of tracks) tr.pattern.fill(false);
      renderDrum();
      setStatus("");
      scheduleSave();
    });

    // -----------------
    // Bass + Lead Sequencer UI
    // -----------------
    const bassResetBtn = document.getElementById("bassReset");
    const leadResetBtn = document.getElementById("leadReset");

    const cutEl = document.getElementById("cutoff");
    const resEl = document.getElementById("reso");
    const envEl = document.getElementById("env");
    const bDecayEl = document.getElementById("bDecay");
    const dMixEl = document.getElementById("dMix");
    const dFbEl  = document.getElementById("dFb");

    const lCutEl = document.getElementById("lCutoff");
    const lResEl = document.getElementById("lReso");
    const lEnvEl = document.getElementById("lEnv");
    const lGateEl= document.getElementById("lGate");
    const lMixEl = document.getElementById("lMix");
    const lFbEl  = document.getElementById("lFb");

    const tbGridEl   = document.getElementById("tb_grid");
    const leadGridEl = document.getElementById("lead_grid");

    const NOTE_NAMES = ["B","A#","A","G#","G","F#","F","E","D#","D","C#","C"];
    const NOTE_TO_SEMI = { "C":0,"C#":1,"D":2,"D#":3,"E":4,"F":5,"F#":6,"G":7,"G#":8,"A":9,"A#":10,"B":11 };

    function makeSeqState(){
      return { steps: Array.from({length:8}, ()=>({ note:null, oct:0 })) };
    }

    let bassState = makeSeqState();
    let leadState = makeSeqState();

    function renderSeqGrid(rootEl, state, kind){
      rootEl.innerHTML = "";

      const labels = document.createElement("div");
      labels.className = "tb_labels";

      const l0 = document.createElement("div");
      l0.className = "muted";
      l0.textContent = "";
      labels.appendChild(l0);

      const l1 = document.createElement("div");
      l1.className = "muted";
      l1.textContent = "Oct";
      labels.appendChild(l1);

      const l2 = document.createElement("div");
      l2.className = "tb_spacer";
      labels.appendChild(l2);

      for(const n of NOTE_NAMES){
        const ln = document.createElement("div");
        ln.className = "muted";
        ln.style.display="flex";
        ln.style.alignItems="center";
        ln.style.justifyContent="flex-start";
        ln.textContent = n;
        labels.appendChild(ln);
      }

      rootEl.appendChild(labels);

      for(let s=0;s<8;s++){
        const col = document.createElement("div");
        col.className = "tb_col";

        const stepNum = document.createElement("div");
        stepNum.className = "tb_stepNum";
        stepNum.textContent = String(s+1);
        col.appendChild(stepNum);

        const octWrap = document.createElement("div");
        octWrap.className = "tb_oct";

        const btnTop = document.createElement("button");
        btnTop.className = "tb_octBtn";
        btnTop.textContent = "";
        btnTop.addEventListener("click", ()=>{
          state.steps[s].oct = +1;
          renderSeqGrid(rootEl, state, kind);
          scheduleSave();
        });

        const btnMid = document.createElement("button");
        btnMid.className = "tb_octBtn";
        btnMid.textContent = "";
        btnMid.addEventListener("click", ()=>{
          state.steps[s].oct = 0;
          renderSeqGrid(rootEl, state, kind);
          scheduleSave();
        });

        const btnBot = document.createElement("button");
        btnBot.className = "tb_octBtn";
        btnBot.textContent = "";
        btnBot.addEventListener("click", ()=>{
          state.steps[s].oct = -1;
          renderSeqGrid(rootEl, state, kind);
          scheduleSave();
        });

        btnTop.classList.toggle("on", state.steps[s].oct === +1);
        btnMid.classList.toggle("on", state.steps[s].oct === 0);
        btnBot.classList.toggle("on", state.steps[s].oct === -1);

        octWrap.appendChild(btnTop);
        octWrap.appendChild(btnMid);
        octWrap.appendChild(btnBot);
        col.appendChild(octWrap);

        const spacer = document.createElement("div");
        spacer.className = "tb_spacer";
        col.appendChild(spacer);

        for(const n of NOTE_NAMES){
          const pad = document.createElement("button");
          pad.className = "tb_pad nat";
          const isOn = state.steps[s].note === n;
          if(isOn) pad.classList.add("on");

          pad.addEventListener("click", async ()=>{
            await resumeAudio();

            if(state.steps[s].note === n) state.steps[s].note = null;
            else state.steps[s].note = n;

            if(state.steps[s].note){
              if(kind==="bass") playBassNoteNow(s);
              else playLeadNoteNow(s);
            }

            renderSeqGrid(rootEl, state, kind);
            scheduleSave();
          });

          col.appendChild(pad);
        }

        rootEl.appendChild(col);
      }

      rootEl.classList.toggle("bass", kind==="bass");
      rootEl.classList.toggle("lead", kind==="lead");
    }

    // -----------------
    // Bass + Lead Synths (FIXED)
    // Fixes:
    // 1) No shared filter automation anymore -> each note has its own filter (prevents "opens up again")
    // 2) Env=0 does ZERO filter movement
    // 3) De-click: small attack + short fade-out always
    // -----------------
    let bassDelayFX = null;
    let leadDelayFX = null;

    function ensureBassLeadFX(){
      if(bassDelayFX && leadDelayFX) return;
      bassDelayFX = makeDelayFX({ mixEl:dMixEl, fbEl:dFbEl }, bassBus, "dotted8");
      leadDelayFX = makeDelayFX({ mixEl:lMixEl, fbEl:lFbEl }, leadBus, "dotted8");
    }

    function cutHzBass(x){ return expMap01(clamp(x,0,1), 40, 7000); }
    function cutHzLead(x){ return expMap01(clamp(x,0,1), 90, 16000); }
    function qFrom01(x){ return 0.6 + Math.pow(clamp(x,0,1), 1.1) * 20.0; }

    function voiceTrigger({
      kind,          // "bass" | "lead"
      freq,
      time,
      decay=0.18,
      gate=0.55,
      envAmt=0.45,
      baseCut01=0.32,
      res01=0.30,
      release=0.10,
      vel=1.0
    }){
      const fx = (kind==="bass") ? bassDelayFX : leadDelayFX;

      const vca = ctx.createGain();
      vca.gain.setValueAtTime(0.00001, time);

      const filt = ctx.createBiquadFilter();
      filt.type = "lowpass";
      filt.Q.setValueAtTime(qFrom01(res01), time);

      // base cutoff
      const baseHz = (kind==="bass") ? cutHzBass(baseCut01) : cutHzLead(baseCut01);
      filt.frequency.setValueAtTime(baseHz, time);

      // connect: osc -> vca -> filter -> (dry+wet)
      vca.connect(filt);
      filt.connect(fx.dry);
      filt.connect(fx.wetIn);

      const osc = ctx.createOscillator();
      osc.type = "sawtooth";
      osc.frequency.setValueAtTime(freq, time);
      osc.connect(vca);

      // AMP ENV (de-click)
      const atk = 0.004;                        // small attack removes click
      const dcy = clamp(decay, 0.03, 0.9);
      const sus = clamp(gate, 0.05, 1.0);
      const rel = clamp(release, 0.05, 0.6);

      // ensure clean slate
      vca.gain.cancelScheduledValues(time);
      vca.gain.setValueAtTime(0.00001, time);
      vca.gain.linearRampToValueAtTime(vel, time + atk);
      vca.gain.setTargetAtTime(vel * sus, time + atk, dcy);
      // always go to ~0 and hold -> avoids end clicks
      const offT = time + dcy + 0.02;
      vca.gain.setTargetAtTime(0.00001, offT, rel);

      // FILTER ENV (Env=0 => no movement, no "re-open")
      const amt01 = clamp(envAmt, 0, 1);
      if(amt01 > 0.001){
        const peak01 = clamp(baseCut01 + (1 - baseCut01) * (amt01 * 0.98), 0, 1);
        const peakHz = (kind==="bass") ? cutHzBass(peak01) : cutHzLead(peak01);

        // cancel then do a short punch, then return exactly to baseHz
        filt.frequency.cancelScheduledValues(time);
        filt.frequency.setValueAtTime(baseHz, time);
        filt.frequency.linearRampToValueAtTime(peakHz, time + 0.012);
        filt.frequency.exponentialRampToValueAtTime(Math.max(30, baseHz), time + dcy + 0.06);
      }

      try{
        osc.start(time);
        osc.stop(time + dcy + rel + 0.35);
      }catch(_){}
    }

    function ensureSynths(){
      ensureBassLeadFX();
      bassDelayFX.update(true);
      leadDelayFX.update(true);
    }

    // realtime param applies (to delay only; filter is per voice)
    bindInput(dMixEl, ()=>{ if(ctx){ ensureSynths(); bassDelayFX.update(false); } scheduleSave(); });
    bindInput(dFbEl,  ()=>{ if(ctx){ ensureSynths(); bassDelayFX.update(false); } scheduleSave(); });
    bindInput(lMixEl, ()=>{ if(ctx){ ensureSynths(); leadDelayFX.update(false); } scheduleSave(); });
    bindInput(lFbEl,  ()=>{ if(ctx){ ensureSynths(); leadDelayFX.update(false); } scheduleSave(); });

    // save-only knobs
    [cutEl,resEl,envEl,bDecayEl,lCutEl,lResEl,lEnvEl,lGateEl].forEach(el=>{
      bindInput(el, ()=>scheduleSave());
    });

    function stepToFreq(kind, stepIndex){
      const st = (kind==="bass") ? bassState.steps[stepIndex] : leadState.steps[stepIndex];
      if(!st.note) return null;

      const baseOct = (kind==="bass") ? 2 : 5;
      const semi = NOTE_TO_SEMI[st.note] ?? 0;
      const midi = (baseOct*12) + semi + (st.oct*12);
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    function playBassNoteNow(stepIndex){
      if(!ctx) return;
      ensureSynths();
      const f = stepToFreq("bass", stepIndex);
      if(!f) return;

      voiceTrigger({
        kind:"bass",
        freq:f,
        time:ctx.currentTime,
        decay:(+bDecayEl.value || 0.18),
        gate:0.55,
        envAmt:(+envEl.value || 0),
        baseCut01:(+cutEl.value || 0),
        res01:(+resEl.value || 0),
        release:0.10,
        vel:1.0
      });
    }

    function playLeadNoteNow(stepIndex){
      if(!ctx) return;
      ensureSynths();
      const f = stepToFreq("lead", stepIndex);
      if(!f) return;

      voiceTrigger({
        kind:"lead",
        freq:f,
        time:ctx.currentTime,
        decay:0.10,
        gate:(+lGateEl.value || 0.55),
        envAmt:(+lEnvEl.value || 0),
        baseCut01:(+lCutEl.value || 0),
        res01:(+lResEl.value || 0),
        release:0.28,
        vel:0.9
      });
    }

    // -----------------
    // Scheduling bass/lead
    // -----------------
    let bassIsRunning=false, bassStep=0, bassNextTime=0, bassTimer=null;
    let leadIsRunning=false, leadStep=0, leadNextTime=0, leadTimer=null;

    function bassSchedule(stepIndex, time){
      const f = stepToFreq("bass", stepIndex);
      if(!f) return;
      ensureSynths();
      voiceTrigger({
        kind:"bass",
        freq:f,
        time,
        decay:(+bDecayEl.value || 0.18),
        gate:0.55,
        envAmt:(+envEl.value || 0),
        baseCut01:(+cutEl.value || 0),
        res01:(+resEl.value || 0),
        release:0.10,
        vel:1.0
      });
    }

    function leadSchedule(stepIndex, time){
      const f = stepToFreq("lead", stepIndex);
      if(!f) return;
      ensureSynths();
      voiceTrigger({
        kind:"lead",
        freq:f,
        time,
        decay:0.10,
        gate:(+lGateEl.value || 0.55),
        envAmt:(+lEnvEl.value || 0),
        baseCut01:(+lCutEl.value || 0),
        res01:(+lResEl.value || 0),
        release:0.28,
        vel:0.9
      });
    }

    function bassScheduler(){
      if(!bassIsRunning) return;
      const base = eighthSec();
      while(bassNextTime < ctx.currentTime + AHEAD_SEC){
        bassSchedule(bassStep, bassNextTime);
        bassStep = (bassStep + 1) % 8;
        bassNextTime += base;
      }
      bassTimer = setTimeout(bassScheduler, LOOKAHEAD_MS);
    }

    function leadScheduler(){
      if(!leadIsRunning) return;
      const base = sixteenthSec();
      while(leadNextTime < ctx.currentTime + AHEAD_SEC){
        leadSchedule(leadStep, leadNextTime);
        leadStep = (leadStep + 1) % 8;
        leadNextTime += base;
      }
      leadTimer = setTimeout(leadScheduler, LOOKAHEAD_MS);
    }

    function bassStart(t0){
      bassIsRunning = true;
      bassStep = 0;
      bassNextTime = t0;
      if(bassTimer) clearTimeout(bassTimer);
      bassScheduler();
    }
    function leadStart(t0){
      leadIsRunning = true;
      leadStep = 0;
      leadNextTime = t0;
      if(leadTimer) clearTimeout(leadTimer);
      leadScheduler();
    }
    function bassStop(){
      bassIsRunning=false;
      if(bassTimer) clearTimeout(bassTimer);
      bassTimer=null;
    }
    function leadStop(){
      leadIsRunning=false;
      if(leadTimer) clearTimeout(leadTimer);
      leadTimer=null;
    }

    bassResetBtn.addEventListener("click", ()=>{
      bassState = makeSeqState();
      renderSeqGrid(tbGridEl, bassState, "bass");
      scheduleSave();
    });
    leadResetBtn.addEventListener("click", ()=>{
      leadState = makeSeqState();
      renderSeqGrid(leadGridEl, leadState, "lead");
      scheduleSave();
    });

    // -----------------
    // Transport
    // -----------------
    let isPlaying=false;

    async function masterPlay(){
      await resumeAudio();
      ensureSynths();
      applyMixerNow(true);

      const t0 = ctx.currentTime + 0.06;
      sharedStartTime = t0;

      const ok = drumStart(t0);
      if(!ok) return;

      bassStart(t0);
      leadStart(t0);

      isPlaying = true;
      masterPlayBtn.disabled = true;
      masterStopBtn.disabled = false;
      setStatus("Playing");
    }

    function masterStop(){
      drumStop();
      bassStop();
      leadStop();

      isPlaying = false;
      masterPlayBtn.disabled = false;
      masterStopBtn.disabled = true;
      setStatus("Stopped");
    }

    masterPlayBtn.addEventListener("click", masterPlay);
    masterStopBtn.addEventListener("click", masterStop);

    // -----------------
    // Recording countdown 60 -> 0
    // -----------------
    const recBtn = document.getElementById("recBtn");
    const recStopBtn = document.getElementById("recStopBtn");
    const recExportBtn = document.getElementById("recExportBtn");
    const recCountdownEl = document.getElementById("recCountdown");
    const recFillEl = document.getElementById("recFill");

    let recTick = null;
    let recStartMs = 0;

    function resetCountdownUI(){
      recCountdownEl.textContent = "60";
      recFillEl.style.width = "0%";
    }
    resetCountdownUI();

    function startCountdownUI(){
      recStartMs = performance.now();
      if(recTick) clearInterval(recTick);
      recTick = setInterval(()=>{
        const elapsed = (performance.now() - recStartMs) / 1000;
        const remain = clamp(60 - elapsed, 0, 60);
        recCountdownEl.textContent = String(Math.ceil(remain));
        recFillEl.style.width = `${clamp((elapsed/60)*100, 0, 100)}%`;
        if(remain <= 0){
          clearInterval(recTick);
          recTick = null;
        }
      }, 120);
    }

    function stopCountdownUI(){
      if(recTick){ clearInterval(recTick); recTick = null; }
      resetCountdownUI();
    }

    function wavFromFloat32(chL, chR, sampleRate){
      const n = Math.min(chL.length, chR.length);
      const bytesPerSample = 2;
      const blockAlign = 2 * bytesPerSample;
      const byteRate = sampleRate * blockAlign;
      const dataSize = n * blockAlign;

      const buffer = new ArrayBuffer(44 + dataSize);
      const view = new DataView(buffer);

      function writeStr(off, s){
        for(let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i));
      }

      writeStr(0, "RIFF");
      view.setUint32(4, 36 + dataSize, true);
      writeStr(8, "WAVE");

      writeStr(12, "fmt ");
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, 2, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, byteRate, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);

      writeStr(36, "data");
      view.setUint32(40, dataSize, true);

      let o = 44;
      for(let i=0;i<n;i++){
        const l = clamp(chL[i], -1, 1);
        const r = clamp(chR[i], -1, 1);
        view.setInt16(o, Math.round(l * 32767), true); o += 2;
        view.setInt16(o, Math.round(r * 32767), true); o += 2;
      }
      return new Blob([buffer], { type:"audio/wav" });
    }

    function startMasterRecord(){
      if(!ctx || !recDest) return;
      if(mediaRec && mediaRec.state === "recording") return;

      try{
        recChunks = [];
        recBlob = null;

        mediaRec = new MediaRecorder(recDest.stream);
        mediaRec.ondataavailable = (e)=>{ if(e.data && e.data.size) recChunks.push(e.data); };
        mediaRec.onstop = async ()=>{
          try{
            recBlob = new Blob(recChunks, { type: mediaRec.mimeType || "audio/webm" });
            recExportBtn.disabled = false;
            setStatus("Recorded ✅ (export klaar)");
          }catch(err){
            console.error(err);
            setStatus("Record failed");
          }finally{
            stopCountdownUI();
          }
        };

        mediaRec.start();
        setStatus("Recording… (60s)");

        recBtn.disabled = true;
        recStopBtn.disabled = false;
        recExportBtn.disabled = true;

        startCountdownUI();
        recTimeout = setTimeout(()=>stopMasterRecord(), 60000);
      }catch(err){
        console.error(err);
        setStatus("Recording not supported");
      }
    }

    function stopMasterRecord(){
      if(recTimeout){ clearTimeout(recTimeout); recTimeout=null; }
      if(mediaRec && mediaRec.state === "recording"){
        try{ mediaRec.stop(); }catch(_){}
      }else{
        stopCountdownUI();
      }
      recBtn.disabled = false;
      recStopBtn.disabled = true;
    }

    async function exportMasterWav(){
      if(!recBlob || !ctx) return;

      try{
        const arr = await recBlob.arrayBuffer();
        const abuf = await new Promise((resolve,reject)=>ctx.decodeAudioData(arr, resolve, reject));

        const chL = abuf.getChannelData(0);
        const chR = (abuf.numberOfChannels > 1) ? abuf.getChannelData(1) : abuf.getChannelData(0);

        const wav = wavFromFloat32(chL, chR, abuf.sampleRate);

        const a = document.createElement("a");
        a.href = URL.createObjectURL(wav);
        a.download = "master_recording.wav";
        document.body.appendChild(a);
        a.click();
        a.remove();

        setStatus("WAV exported ✅");
      }catch(err){
        console.error(err);
        setStatus("Export failed");
      }
    }

    recBtn.addEventListener("click", async ()=>{
      await resumeAudio();
      startMasterRecord();
    });
    recStopBtn.addEventListener("click", stopMasterRecord);
    recExportBtn.addEventListener("click", exportMasterWav);

    // -----------------
    // State
    // -----------------
    function gatherState(){
      return {
        tempo: tempo(),
        masterVol: +masterVol.value,
        tracks: tracks.map(t=>({ key:t.key, pattern:[...t.pattern] })),
        bass: bassState,
        lead: leadState,
        params:{
          cut:+cutEl.value, res:+resEl.value, env:+envEl.value, bDecay:+bDecayEl.value, dMix:+dMixEl.value, dFb:+dFbEl.value,
          lCut:+lCutEl.value, lRes:+lResEl.value, lEnv:+lEnvEl.value, lGate:+lGateEl.value, lMix:+lMixEl.value, lFb:+lFbEl.value,
          m:{
            dV:+mDrumVolEl.value, bV:+mBassVolEl.value, lV:+mLeadVolEl.value,
            dF:+mDrumLPFEl.value, bF:+mBassLPFEl.value, lF:+mLeadLPFEl.value,
            dm:mute.drums, bm:mute.bass, lm:mute.lead
          }
        }
      };
    }

    function applyState(st){
      try{
        if(!st) return;

        if(st.tempo) tempoEl.value = String(clamp(st.tempo,80,160));
        tempoVal.textContent = String(tempo());

        if(typeof st.masterVol === "number") masterVol.value = String(clamp(st.masterVol,0,1));

        if(Array.isArray(st.tracks)){
          for(const savedTr of st.tracks){
            const tr = tracks.find(x=>x.key===savedTr.key);
            if(tr && Array.isArray(savedTr.pattern) && savedTr.pattern.length===16){
              tr.pattern = savedTr.pattern.map(Boolean);
            }
          }
        }

        if(st.bass && st.bass.steps && st.bass.steps.length===8) bassState = st.bass;
        if(st.lead && st.lead.steps && st.lead.steps.length===8) leadState = st.lead;

        if(st.params){
          if(typeof st.params.cut==="number") cutEl.value = String(clamp(st.params.cut,0,1));
          if(typeof st.params.res==="number") resEl.value = String(clamp(st.params.res,0,1));
          if(typeof st.params.env==="number") envEl.value = String(clamp(st.params.env,0,1));
          if(typeof st.params.bDecay==="number") bDecayEl.value = String(clamp(st.params.bDecay,0.05,0.45));
          if(typeof st.params.dMix==="number") dMixEl.value = String(clamp(st.params.dMix,0,1));
          if(typeof st.params.dFb==="number") dFbEl.value = String(clamp(st.params.dFb,0,0.75));

          if(typeof st.params.lCut==="number") lCutEl.value = String(clamp(st.params.lCut,0,1));
          if(typeof st.params.lRes==="number") lResEl.value = String(clamp(st.params.lRes,0,1));
          if(typeof st.params.lEnv==="number") lEnvEl.value = String(clamp(st.params.lEnv,0,1));
          if(typeof st.params.lGate==="number") lGateEl.value = String(clamp(st.params.lGate,0.10,1));
          if(typeof st.params.lMix==="number") lMixEl.value = String(clamp(st.params.lMix,0,1));
          if(typeof st.params.lFb==="number") lFbEl.value = String(clamp(st.params.lFb,0,0.75));

          if(st.params.m){
            mDrumVolEl.value = String(clamp(st.params.m.dV ?? +mDrumVolEl.value,0,1));
            mBassVolEl.value = String(clamp(st.params.m.bV ?? +mBassVolEl.value,0,1));
            mLeadVolEl.value = String(clamp(st.params.m.lV ?? +mLeadVolEl.value,0,1));
            mDrumLPFEl.value = String(clamp(st.params.m.dF ?? +mDrumLPFEl.value,0,1));
            mBassLPFEl.value = String(clamp(st.params.m.bF ?? +mBassLPFEl.value,0,1));
            mLeadLPFEl.value = String(clamp(st.params.m.lF ?? +mLeadLPFEl.value,0,1));

            mute.drums = !!st.params.m.dm;
            mute.bass  = !!st.params.m.bm;
            mute.lead  = !!st.params.m.lm;

            mDrumMuteBtn.classList.toggle("on", mute.drums);
            mBassMuteBtn.classList.toggle("on", mute.bass);
            mLeadMuteBtn.classList.toggle("on", mute.lead);
            mDrumMuteBtn.textContent = mute.drums ? "Muted" : "Mute";
            mBassMuteBtn.textContent = mute.bass ? "Muted" : "Mute";
            mLeadMuteBtn.textContent = mute.lead ? "Muted" : "Mute";
          }
        }

        renderDrum();
        renderSeqGrid(tbGridEl, bassState, "bass");
        renderSeqGrid(leadGridEl, leadState, "lead");
      }catch(err){
        console.error(err);
      }
    }

    // -----------------
    // Init
    // -----------------
    hookMixer();
    buildHeader();
    renderDrum();
    renderSeqGrid(tbGridEl, bassState, "bass");
    renderSeqGrid(leadGridEl, leadState, "lead");

    loadAllSounds();

    const saved = loadSaved();
    if(saved){
      applyState(saved);
      setStatus("Autosave loaded ✅");
    }else{
      setStatus("Ready");
    }
  })();
  </script>
</body>

</html>